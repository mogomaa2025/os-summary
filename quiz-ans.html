<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>مراجعة أسئلة البرمجة (الجزء الأول: 1-20)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-bg: #f8f9fa;
            --secondary-bg: #ffffff;
            --text-color: #212529;
            --accent-color: #007bff;
            --border-color: #dee2e6;
            --keyword-color: #d9534f;
            --code-bg: #e9ecef;
            --success-color: #28a745;
            --error-color: #dc3545;
            --info-color: #17a2b8;
        }
        html { scroll-behavior: smooth; }
        body {
            font-family: 'Cairo', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-color);
            line-height: 1.8;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background-color: var(--secondary-bg);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        h1 {
            text-align: center;
            color: var(--accent-color);
            margin-bottom: 30px;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 15px;
        }
        .accordion-item {
            border: 1px solid var(--border-color);
            margin-bottom: 10px;
            border-radius: 8px;
            overflow: hidden;
            transition: box-shadow 0.3s ease;
        }
        .accordion-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }
        .accordion-header {
            background-color: #fff;
            color: #333;
            cursor: pointer;
            padding: 15px 20px;
            width: 100%;
            text-align: right;
            border: none;
            outline: none;
            font-size: 1.1rem;
            font-weight: 700;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s ease;
        }
        .accordion-item.active .accordion-header,
        .accordion-header:hover {
            background-color: #f1f3f5;
        }
        .accordion-header .icon {
            font-size: 1.5rem;
            font-weight: bold;
            transition: transform 0.3s ease;
            color: var(--accent-color);
            flex-shrink: 0;
            margin-left: 15px;
        }
        .accordion-header .question-title { flex-grow: 1; }
        .accordion-item.active .accordion-header .icon { transform: rotate(45deg); }
        .accordion-body {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out;
            background-color: #fff;
            padding: 0 20px;
            border-top: 1px solid var(--border-color);
        }
        .accordion-item.active .accordion-body { padding: 20px; }
        .keyword, .type { color: var(--keyword-color); font-weight: bold; }
        .type { color: var(--info-color); }
        code {
            background-color: var(--code-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            direction: ltr;
            display: inline-block;
            font-size: 0.95em;
            color: #333;
        }
        .output, .answer {
            background-color: #e6f7ff;
            border-right: 4px solid var(--accent-color);
            padding: 15px;
            margin-top: 15px;
            border-radius: 5px;
        }
        .answer.true { background-color: #e9f7ef; border-right-color: var(--success-color); }
        .answer.false { background-color: #fceeee; border-right-color: var(--error-color); }
        ul { padding-right: 20px; }
        li { margin-bottom: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء الأول: 1-20)</h1>
        <div class="accordion">

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 1: الغموض عند استدعاء الدوال (Ambiguous Call)</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عندما لا يستطيع المترجم (<code class="keyword">Compiler</code>) التمييز بين دالتين مُعاد تحميلهما (<code class="keyword">overloaded functions</code>) بناءً على الوسائط المُمررة، يحدث خطأ يسمى <code class="type">Ambiguous call</code> (استدعاء غامض).</p>
                    <p>هذا يعني أن المترجم لا يستطيع تحديد أي نسخة من الدالة يجب استدعاؤها، مما يؤدي إلى خطأ في الترجمة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Ambiguous.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 2: تعريف المتغير غير الثابت (Instance Variable)</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>المتغير غير الثابت (<code class="keyword">Instance variable</code>) هو متغير يتم إعلانه داخل <code class="keyword">Class</code> ولكن خارج أي دالة (<code class="keyword">method</code>). كل كائن (<code class="keyword">object</code>) من هذا الكلاس يمتلك نسخته الخاصة المستقلة من هذا المتغير.</p>
                    <p>يمكن الوصول إليه من أي دالة داخل نفس الكلاس، سواء كان في قسم <code class="keyword">private</code>, <code class="keyword">protected</code>, أو <code class="keyword">public</code>.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> It is a variable declared in any section in a class and can be accessed by any method in the same class.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 3: استخدام الـ Constructor لمهام التهيئة الخاصة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>إذا كان الـ <code class="keyword">Class</code> الذي تصممه يحتاج إلى مهام تهيئة خاصة (<code class="type">special initialization tasks</code>) عند إنشاء كائن منه، فإنك تحتاج إلى تعريف <code class="keyword">Constructor</code>.</p>
                    <p>الـ <code class="keyword">Constructor</code> هو دالة خاصة تُستدعى تلقائيًا عند إنشاء كائن جديد، وهو المكان المثالي لوضع أي منطق تهيئة مطلوب.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Constructor.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 4: توقع الـ Output عند إعادة تعريف متغير</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكود يحاول تعريف نفس المتغير (<code dir="ltr">y</code>) مرتين في نفس النطاق (<code class="keyword">scope</code>). هذا غير مسموح به في لغة C++.</p>
                    <p>سيقوم المترجم (<code class="keyword">Compiler</code>) بإصدار خطأ في وقت الترجمة (<code class="type">compile-time error</code>) بسبب إعادة التعريف.</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compile time error.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 5: أفضل وصف لعلاقة الـ Association</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>علاقة الـ <code class="type">Association</code> (الارتباط) بين الكلاسات تحدث عندما يستخدم كلاس (<code class="keyword">Class</code>) كائنات (<code class="keyword">objects</code>) من كلاس آخر. هذا يعني أن كلاسًا ما يحتاج إلى استخدام وظائف (<code class="keyword">methods</code>) أو خصائص (<code class="keyword">properties</code>) من كلاس آخر لإكمال مهامه.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> When a class is using object(s) from other class(es).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 6: توقع الـ Output عند تجاوز سعة الـ signed char</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>نوع البيانات <code class="type">signed char</code> في C يمتد نطاقه عادةً من -128 إلى 127.</p>
                    <p>عندما تحاول إسناد قيمة 128 (وهي خارج النطاق) إلى متغير من هذا النوع، يحدث فيضان (<code class="type">overflow</code>). السلوك في هذه الحالة هو "الالتفاف" (wrap-around) إلى أدنى قيمة في النطاق، وهي -128.</p>
                    <p>ملاحظة: تقنيًا، هذا السلوك يعتبر <code class="type">undefined behavior</code> في معيار اللغة، لكنه السلوك الشائع في معظم المترجمات.</p>
                    <div class="output"><strong>الـ Output هو:</strong> -128.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 7: مصطلح إخفاء البيانات خلف دوال الكلاس</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>المصطلح الذي يشير إلى "إخفاء البيانات وراء دوال الكلاس" هو <code class="type">Encapsulation</code> (التغليف).</p>
                    <p>التغليف هو أحد المبادئ الأساسية في البرمجة كائنية التوجه، ويعني تجميع البيانات (<code class="keyword">attributes</code>) والدوال (<code class="keyword">methods</code>) التي تعمل عليها في وحدة واحدة (<code class="keyword">Class</code>)، وتقييد الوصول المباشر إلى البيانات الداخلية.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Encapsulation.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 8: توقع الـ Output عند استدعاء Base Constructor بشكل خاطئ</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكود سيُصدر خطأ ترجمة (<code class="type">Compilation Error</code>). السبب هو أن الـ <code class="keyword">constructor</code> الخاص بالكلاس المشتق (<code class="keyword">Child</code>) يحاول استدعاء <code class="keyword">constructor</code> الكلاس الأساسي (<code class="keyword">Base</code>) الذي لا يأخذ أي وسائط (<code class="type">default constructor</code>)، ولكن هذا الـ <code class="keyword">constructor</code> غير موجود.</p>
                    <p>الكلاس <code class="keyword">Base</code> لديه فقط <code class="keyword">constructor</code> واحد يأخذ وسيطًا من نوع <code class="type">int</code>. لذلك، يجب على <code class="keyword">Child</code> استدعاؤه بشكل صريح في قائمة التهيئة (<code class="keyword">initializer list</code>).</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compilation Error.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 9: توقع الـ Output عند وجود غموض في Function Overloading</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكود يحتوي على دالتين باسم <code dir="ltr">sum</code>، واحدة تقبل <code class="type">int, int</code> والأخرى <code class="type">float, float</code>. عند استدعاء <code dir="ltr">sum(4.3, 2.7)</code>، تكون القيم من نوع <code class="type">double</code> بشكل افتراضي.</p>
                    <p>لأن المترجم لا يجد دالة تقبل <code class="type">double</code>، فإنه يحاول إجراء تحويل ضمني. لكن التحويل إلى <code class="type">int</code> والتحويل إلى <code class="type">float</code> كلاهما ممكن، مما يخلق غموضًا (<code class="type">ambiguity</code>). لا يستطيع المترجم تحديد أي نسخة هي الأفضل للاستدعاء.</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compiler Error: Ambiguity.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 10: توقع الـ Output عند الوصول لعضو خاص (Private Member)</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>في C++، الأعضاء داخل الـ <code class="keyword">class</code> تكون <code class="keyword">private</code> بشكل افتراضي إذا لم يتم تحديد <code class="keyword">access specifier</code>.</p>
                    <p>لذلك، المتغير <code dir="ltr">x</code> في <code class="keyword">Class Test</code> هو <code class="keyword">private</code>. محاولة الوصول إليه من خارج الكلاس (في دالة <code class="keyword">main</code>) ستؤدي إلى خطأ في الترجمة لأن الأعضاء الخاصة لا يمكن الوصول إليها إلا من داخل الكلاس نفسه.</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compilation error regarding the variable x.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 11: توقع الـ Output لكود يستخدم Virtual Functions</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>يوضح الكود مفهوم <code class="type">Polymorphism</code> باستخدام الدوال الافتراضية (<code class="keyword">virtual functions</code>).</p>
                    <ul>
                        <li>عندما يشير المؤشر <code dir="ltr">pb</code> إلى كائن من <code class="keyword">Test</code>، فإن استدعاء <code dir="ltr">pb->say()</code> ينفذ نسخة الدالة من الكلاس <code class="keyword">Test</code> ويطبع "Test".</li>
                        <li>عندما يشير نفس المؤشر إلى كائن من <code class="keyword">NewTest</code>، فإن استدعاء <code dir="ltr">pb->say()</code> ينفذ نسخة الدالة من الكلاس <code class="keyword">NewTest</code> بفضل آلية الربط الديناميكي (<code class="type">runtime polymorphism</code>) ويطبع "NewTest".</li>
                    </ul>
                    <div class="output"><strong>الـ Output هو:</strong> Test NewTest.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 12: توقع الـ Output لترتيب استدعاء الـ Constructors</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عند إنشاء كائن من كلاس مشتق (<code class="keyword">derived class</code>)، يتم استدعاء الـ <code class="keyword">constructor</code> الخاص بالكلاس الأساسي (<code class="keyword">base class</code>) أولاً، ثم يتم استدعاء الـ <code class="keyword">constructor</code> الخاص بالكلاس المشتق.</p>
                    <ol>
                        <li>يتم استدعاء <code dir="ltr">Base()</code> ويطبع "Welcome".</li>
                        <li>يتم استدعاء <code dir="ltr">Derived()</code> ويطبع "Hello".</li>
                    </ol>
                    <div class="output"><strong>الـ Output هو:</strong> Welcome Hello.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 13: وظيفة <code>new float(15)</code></span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>التعبير <code dir="ltr">new float(15)</code> يقوم بتخصيص ذاكرة ديناميكيًا في الـ <code class="keyword">heap</code> لمتغير واحد من نوع <code class="type">float</code>.</p>
                    <p>الأقواس <code dir="ltr">(15)</code> بعد النوع تعني أن هذا المتغير سيتم تهيئته بالقيمة 15.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Allocate space for a float variable that is initialized by the value 15.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 14: وظيفة <code>new float[15]</code></span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>التعبير <code dir="ltr">new float[15]</code> يقوم بتخصيص ذاكرة ديناميكيًا في الـ <code class="keyword">heap</code> لمصفوفة (<code class="keyword">array</code>) تحتوي على 15 عنصرًا من نوع <code class="type">float</code>.</p>
                    <p>عند استخدام هذا الشكل لتخصيص مصفوفة من الأنواع الأساسية، لا يتم تهيئة العناصر، وستحتوي على قيم عشوائية (<code class="type">garbage values</code>).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Allocate space for an array of 15 float elements that are not initialized.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 15: ما يجب أن يتضمنه أي Abstract Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لكي يكون الكلاس كلاسًا مجردًا (<code class="type">Abstract Class</code>)، يجب أن يحتوي على دالة افتراضية نقية (<code class="keyword">pure virtual function</code>) واحدة على الأقل.</p>
                    <p>الدالة الافتراضية النقية هي دالة ليس لها جسم (implementation) في الكلاس الأساسي ويتم تعريفها بإضافة <code dir="ltr">= 0</code>.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> At least a pure virtual function.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 16: ترتيب تنفيذ الـ Destructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>ترتيب تنفيذ الـ <code class="keyword">Destructors</code> هو عكس ترتيب تنفيذ الـ <code class="keyword">Constructors</code>.</p>
                    <p>عندما يتم تدمير كائن من كلاس مشتق، يتم استدعاء الـ <code class="keyword">destructor</code> الخاص بالكلاس المشتق أولاً، ثم يتم استدعاء الـ <code class="keyword">destructor</code> الخاص بالكلاس الأساسي.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> After the body of the destructor of the derived class is executed.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 17: أفضل وصف للعلاقة بين وسائل النقل</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا مثال كلاسيكي على الوراثة (<code class="type">Inheritance</code>). <code class="keyword">Transportation_Mean</code> هو الكلاس الأساسي العام. <code class="keyword">Car</code> و <code class="keyword">Bicycle</code> هما كلاسات مشتقة أكثر تخصصًا.</p>
                    <p>كلاهما يرث الخصائص المشتركة (مثل <code dir="ltr">color</code>) من الكلاس الأساسي، ثم يضيفان خصائصهما الفريدة (مثل <code dir="ltr">motor</code> للسيارة و <code dir="ltr">handlebar</code> للدراجة). هذا يعزز إعادة استخدام الكود (<code class="type">code reuse</code>).</p>
                    <div class="answer"><strong>الإجابة الصحيحة:</strong> الخيار الذي يصف <code class="keyword">Transportation_Mean</code> ككلاس أساسي و <code class="keyword">Car</code> و <code class="keyword">Bicycle</code> ككلاسات مشتقة منه.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 18: أفضل وصف للعلاقة بين الآلات</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا أيضًا مثال على الوراثة (<code class="type">Inheritance</code>). <code class="keyword">Machine</code> هو الكلاس الأساسي الذي يحتوي على خاصية مشتركة (<code dir="ltr">motor</code>). <code class="keyword">Plane</code> و <code class="keyword">Refrigerator</code> هما أنواع متخصصة من الآلات.</p>
                    <p>كلاهما يرث من <code class="keyword">Machine</code> ويضيف خصائصه الفريدة (<code dir="ltr">wings</code> للطائرة و <code dir="ltr">shelves</code> للثلاجة).</p>
                    <div class="answer"><strong>الإجابة الصحيحة:</strong> الخيار الذي يصف <code class="keyword">Machine</code> ككلاس أساسي و <code class="keyword">Plane</code> و <code class="keyword">Refrigerator</code> ككلاسات مشتقة منه.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 19: أمثلة على مزايا البرمجة كائنية التوجه (OOP)</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>مزايا البرمجة كائنية التوجه تشمل:</p>
                    <ul>
                        <li><code class="type">Simplicity</code> (التبسيط): نمذجة العالم الحقيقي.</li>
                        <li><code class="type">Reusability</code> (إعادة الاستخدام): استخدام الكلاسات الموجودة لبناء كلاسات جديدة.</li>
                        <li><code class="type">Encapsulation</code> (التغليف): حماية البيانات.</li>
                        <li><code class="type">Modularity</code> (النمطية): تقسيم النظام إلى وحدات مستقلة.</li>
                        <li><code class="type">Abstraction</code> (التجريد): إخفاء التفاصيل المعقدة.</li>
                    </ul>
                    <div class="answer true"><strong>الإجابة الصحيحة هي:</strong> كل الخيارات صحيحة.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 20: تعريف الـ Embedded Object</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكائن المضمن (<code class="type">Embedded Object</code>) هو كائن (<code class="keyword">object</code>) يوجد كعضو بيانات داخل كائن آخر. هذا يمثل علاقة "جزء من" أو "يحتوي على"، والتي تُعرف بـ <code class="type">Composition</code> أو <code class="type">Aggregation</code>.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> An object included by another object.</div>
                </div>
            </div>

        </div>
    </div>
     <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء الثاني: 21-40)</h1>
        <div class="accordion">

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 21: توقع الـ Output لكود Copy Constructor و Post-increment</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا الكود يختبر فهمًا عميقًا لكيفية عمل الـ constructors والزيادة اللاحقة والسابقة.</p>
                    <ol>
                        <li><b><code dir="ltr">Test t(1);</code></b>: يستدعي <code dir="ltr">Test(int y)</code>. السطر <code dir="ltr">x = y++</code> يعني أن <code dir="ltr">t.x</code> سيأخذ القيمة الحالية لـ <code dir="ltr">y</code> (وهي 1) ثم تزيد <code dir="ltr">y</code>. إذن <code dir="ltr">t.x = 1</code>.</li>
                        <li><b><code dir="ltr">t.print();</code></b>: يطبع قيمة <code dir="ltr">t.x</code>، وهي 1. الـ Output الجزئي: "12".</li>
                        <li><b><code dir="ltr">Test x(t);</code></b>: يستدعي الـ <code class="keyword">copy constructor</code> <code dir="ltr">Test(Test &r)</code>، حيث <code dir="ltr">r</code> تشير إلى <code dir="ltr">t</code>.
                           <ul>
                               <li>الجسم هو <code dir="ltr">x = ++r.x;</code>.</li>
                               <li><code dir="ltr">++r.x</code> (زيادة سابقة) يزيد <code dir="ltr">r.x</code> (أي <code dir="ltr">t.x</code>) أولاً، فتصبح قيمتها 2.</li>
                               <li>ثم يتم إسناد القيمة الجديدة (2) إلى <code dir="ltr">x.x</code>. إذن <code dir="ltr">x.x = 2</code>.</li>
                           </ul>
                        </li>
                        <li><b><code dir="ltr">x.print();</code></b>: يطبع قيمة <code dir="ltr">x.x</code>، وهي 2. الـ Output الجزئي: "122".</li>
                        <li><b><code dir="ltr">t.print();</code></b>: يطبع قيمة <code dir="ltr">t.x</code>، والتي تم تغييرها إلى 2 داخل الـ copy constructor. الـ Output الجزئي: "122".</li>
                    </ol>
                     <div class="output"><strong>ملاحظة:</strong> تحليل المستند الأصلي صحيح، لكنه يدمج الأرقام. المخرجات الفعلية ستكون "1 2 2" مع فواصل أسطر أو مسافات، لكن النتيجة الرقمية المدمجة هي 122.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 22: إضافة إمكانية جمع قيم كائنين</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لتمكين عملية الجمع بين كائنين باستخدام المعامل <code dir="ltr">+</code> (مثل <code dir="ltr">test3 = test1 + test2</code>)، يجب عليك القيام بإعادة تحميل المعامل (<code class="keyword">operator overloading</code>) للمعامل <code dir="ltr">+</code> داخل الكلاس الخاص بك.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> a. Do operator + overloading.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 23: سبب استخدام البرمجة كائنية التوجه (OOP)</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>أحد أهم الأسباب لاستخدام OOP هو أن الكود يمكن إعادة استخدامه (<code class="type">reusable</code>). عندما تكتب <code class="keyword">Class</code> جيدًا، يمكنك استخدامه في أجزاء مختلفة من برنامجك أو حتى في مشاريع أخرى تمامًا. هذا يقلل من تكرار الكود، يوفر الوقت، ويقلل من الأخطاء.</p>
                    <div class="answer"><strong>السبب الرئيسي المذكور:</strong> الكود قابل لإعادة الاستخدام.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 24: استخدام الـ Inheritance لتوسيع وظائف الـ Base Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الوراثة (<code class="keyword">Inheritance</code>) هي آلية أساسية في OOP تسمح لكلاس جديد (<code class="keyword">derived class</code>) بأن يرث الخصائص (<code class="keyword">properties</code>) والسلوكيات (<code class="keyword">behaviors</code>) من كلاس موجود (<code class="keyword">base class</code>). هذا يسمح بتوسيع وظائف الكلاس الأساسي بدلاً من إعادة كتابتها من الصفر.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Extending base class functionality.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 25: أمثلة على Polymorphism</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>تعدد الأشكال (<code class="type">Polymorphism</code>) يعني "أشكال متعددة". في البرمجة، يسمح بمعاملة الكائنات بشكل مختلف بناءً على نوعها الفعلي.</p>
                    <ul>
                        <li><b>Operator Overloading:</b> مثال على تعدد الأشكال في وقت الترجمة (<code class="type">compile-time polymorphism</code>)، حيث يتصرف المعامل بشكل مختلف حسب أنواع البيانات.</li>
                        <li><b>Function Overriding:</b> مثال على تعدد الأشكال في وقت التشغيل (<code class="type">run-time polymorphism</code>)، حيث تقوم الكلاسات المشتقة بإعادة تعريف سلوك دالة موروثة.</li>
                    </ul>
                    <div class="answer true"><strong>الإجابة الصحيحة هي:</strong> a. Operator overloading و b. Function overriding.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 26: توقع الـ Output عند الوصول لدالة خاصة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>في <code class="keyword">class C</code>، الأعضاء تكون <code class="keyword">private</code> بشكل افتراضي. لذا، الدالة <code dir="ltr">seti(int r)</code> هي دالة خاصة.</p>
                    <p>محاولة استدعاء دالة خاصة من خارج الكلاس (في دالة <code class="keyword">main</code> عبر الكائن <code dir="ltr">x</code>) ستؤدي إلى خطأ في الترجمة (<code class="type">compilation error</code>).</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> The compiler generates an error because the method “seti” is not accessible.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 27: توقع الـ Output عند استخدام متغير غير مُعرّف</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>في حلقة <code class="keyword">for</code>، يتم استخدام المتغير <code dir="ltr">i</code> دون تعريفه مسبقًا. في C++، يجب تعريف المتغيرات قبل استخدامها.</p>
                    <p>سيؤدي هذا إلى خطأ في الترجمة لأن المترجم لا يعرف ما هو الرمز <code dir="ltr">i</code>.</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> An error occurs because the var i is not visible in the for loop (undefined symbol i).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 28: ترتيب استدعاء الـ Constructor في الوراثة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عند إنشاء كائن من كلاس مشتق، يتم دائمًا استدعاء الـ <code class="keyword">constructor</code> الخاص بالكلاس الأساسي (<code class="keyword">Base Class</code>) أولاً.</p>
                    <p>هذا يضمن أن الجزء الموروث من الكائن يتم تهيئته بشكل صحيح قبل أن يبدأ الكلاس المشتق في إضافة سلوكياته أو بياناته الخاصة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Before the constructor of the derived class started. (وهي نفس فكرة سؤال 12).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 29: استخدام المؤشر 'this' في الدوال الأعضاء</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>في دالة عضو، الوسيط (<code class="keyword">parameter</code>) <code dir="ltr">k</code> يحجب (shadows) المتغير العضو (<code class="keyword">member variable</code>) <code dir="ltr">k</code>.</p>
                    <p>للتفريق بينهما والوصول إلى المتغير العضو، نستخدم المؤشر <code class="keyword">this</code>، الذي يشير إلى الكائن الحالي. الصيغة الصحيحة هي <code dir="ltr">this->k = k;</code>، والتي تعني "اجعل المتغير العضو <code dir="ltr">k</code> الخاص بهذا الكائن يساوي قيمة الوسيط <code dir="ltr">k</code>".</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> <code dir="ltr">this->k=k;</code>.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 30: توقع الـ Output عند محاولة إنشاء كائن من Abstract Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلاس <code class="keyword">Person</code> هو كلاس مجرد (<code class="type">Abstract Class</code>) لأنه يحتوي على دالة افتراضية نقية (<code dir="ltr">virtual void talk() = 0;</code>).</p>
                    <p>لا يمكن إنشاء كائنات مباشرة من الكلاسات المجردة. محاولة القيام بذلك (مثل <code dir="ltr">Person p;</code>) ستؤدي إلى خطأ في الترجمة.</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Produces an error.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 31: الـ Constructors المطلوبة في الوراثة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا السؤال مكرر (نفس السؤال 211 و 167).</p>
                    <p>عندما يكون للكلاس الأساسي (<code class="keyword">Base</code>) <code class="keyword">constructors</code> مخصصة، ولا يوجد <code class="type">default constructor</code>، يجب على الكلاس المشتق (<code class="keyword">Child</code>) استدعاء أحد الـ <code class="keyword">constructors</code> المتاحة في الكلاس الأساسي بشكل صريح في قائمة التهيئة.</p>
                    <p>الكود يحتاج إلى وجود <code class="type">default constructor</code> في <code class="keyword">Base</code> (ليتم استدعاؤه ضمنيًا) و <code class="keyword">constructor</code> يأخذ <code class="type">int, int</code> (ليتم استدعاؤه صراحةً).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> <code dir="ltr">Base()</code> و <code dir="ltr">Base(int, int)</code> يجب أن يكونا موجودين.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 32: تعريف الكلاس الذي يحتوي على Pure Virtual Function</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلاس الذي يحتوي على دالة افتراضية نقية (<code class="keyword">pure virtual function</code>) واحدة على الأقل يُسمى كلاسًا مجردًا (<code class="type">Abstract class</code>). هذا هو التعريف الرسمي للكلاس المجرد في C++.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Abstract class.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 33: توقع الـ Output لدالة void تُرجع قيمة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدالة <code dir="ltr">getc</code> مُعلنة على أنها تُرجع <code class="keyword">void</code>، مما يعني أنها لا تُرجع أي قيمة.</p>
                    <p>ومع ذلك، جسم الدالة يحتوي على العبارة <code dir="ltr">return c;</code>، التي تحاول إرجاع قيمة. هذا تعارض مع تعريف الدالة وسيؤدي إلى خطأ في الترجمة (<code class="type">compilation error</code>) بسبب عدم تطابق نوع الإرجاع.</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> None of the above, it generates an error.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 34: توقع الـ Output عند استخدام delete على كائن في الـ Stack</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكائن <code dir="ltr">s1</code> تم إنشاؤه على المكدس (<code class="keyword">stack</code>)، وهو ما يعني أن ذاكرته تُدار تلقائيًا. المعامل <code class="keyword">delete</code> يُستخدم فقط لتحرير الذاكرة التي تم تخصيصها ديناميكيًا على الكومة (<code class="keyword">heap</code>) باستخدام <code class="keyword">new</code>.</p>
                    <p>محاولة استخدام <code class="keyword">delete</code> على كائن موجود على المكدس هي عملية غير صالحة وستؤدي إلى خطأ في الترجمة.</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Line 4 generates an error.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 35: توقع الـ Output لـ Function Overloading Resolution</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلاس <code class="keyword">Test</code> لديه دالتان باسم <code dir="ltr">print</code>، واحدة تقبل <code class="type">int</code> والأخرى <code class="type">char*</code>.</p>
                    <p>عند استدعاء <code dir="ltr">t.print('a');</code>، الوسيط هو من نوع <code class="type">char</code>. لا توجد دالة تقبل <code class="type">char</code> بالضبط، ولكن المترجم يمكنه إجراء تحويل ضمني (<code class="type">implicit conversion</code>) من <code class="type">char</code> إلى <code class="type">int</code>. هذا التحويل يعتبر "أفضل تطابق" من التحويل إلى <code class="type">char*</code>.</p>
                    <p>لذلك، سيتم استدعاء النسخة التي تقبل <code class="type">int</code>.</p>
                    <div class="output"><strong>الإجابة:</strong> الكود سيقوم بالترجمة ويطبع "int version".</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 36: توقع الـ Output لـ Private Inheritance Access</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عندما يرث كلاس <code class="keyword">Child</code> من <code class="keyword">Base</code> باستخدام الوراثة الخاصة (<code class="keyword">private inheritance</code>)، فإن جميع الأعضاء العامة (<code class="keyword">public</code>) والمحمية (<code class="keyword">protected</code>) في الكلاس الأساسي تصبح أعضاء خاصة (<code class="keyword">private</code>) في الكلاس المشتق.</p>
                    <p>لذا، المتغير <code dir="ltr">x</code> يصبح <code class="keyword">private</code> في <code class="keyword">Child</code>. محاولة الوصول إليه من خارج الكلاس (<code class="keyword">main</code>) ستؤدي إلى خطأ في الترجمة.</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compiler error because of the Child inheritance from private.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 37: تعريف الـ Constructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الـ <code class="keyword">Constructor</code> هو دالة عضو خاصة وظيفتها الأساسية هي تهيئة (<code class="keyword">initialize</code>) متغيرات البيانات الخاصة بالكائن عند إنشائه. إنه يضمن أن الكائن يبدأ في حالة صالحة ومعروفة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> c) A member function that is used to initialize variables of a declared object.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 38: إضافة إمكانية اختبار تساوي الكائنات</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لتوفير طريقة مخصصة لمقارنة كائنين من نفس الكلاس باستخدام معامل المساواة (<code dir="ltr">==</code>)، كما في <code dir="ltr">if (obj1 == obj2)</code>، يجب عليك القيام بإعادة تحميل المعامل (<code class="keyword">operator overloading</code>) للمعامل <code dir="ltr">==</code>.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> b) Do operator == overloading.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 39: عبارات صحيحة عن الـ Destructors</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الخصائص الصحيحة للمُدمِّرات (<code class="keyword">Destructors</code>) هي:</p>
                    <ul>
                        <li>لها نفس اسم الكلاس مسبوقًا بعلامة التلدة (~).</li>
                        <li>لا يمكن إعادة تحميلها (<code class="type">cannot be overloaded</code>)؛ لكل كلاس مُدمِّر واحد فقط.</li>
                        <li>لا تُرجع أي قيمة (<code class="type">no return type</code>)، ولا حتى <code class="keyword">void</code>.</li>
                    </ul>
                    <div class="answer true"><strong>الإجابة الصحيحة هي:</strong> d) All of the above.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 40: وصف عملية Function Overloading</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>إعادة تحميل الدوال (<code class="keyword">Function Overloading</code>) تسمح بوجود أكثر من دالة بنفس الاسم في نفس النطاق، طالما أن قوائم وسائطها (<code class="keyword">parameter lists</code>) مختلفة. الاختلاف يمكن أن يكون في عدد الوسائط، أو أنواعها، أو ترتيبها.</p>
                    <p>هذا يسمح باستخدام نفس اسم الدالة لأداء مهام متشابهة على أنواع مختلفة من البيانات.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> c) A method with the same name but different parameters gives multiple uses for the same method name.</div>
                </div>
            </div>


        </div>
    </div>

        <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء الثالث: 41-60)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 41: توقع الـ Output لكود Private Member Access</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا السؤال مكرر (نفس السؤال 254 و 177). في الكلاس، المتغير <code dir="ltr">x</code> يكون <code class="keyword">private</code> افتراضيًا.</p>
                    <p>محاولة الوصول إلى <code dir="ltr">obj.x</code> من دالة <code class="keyword">main</code> (خارج الكلاس) ستؤدي إلى خطأ في الترجمة (<code class="type">compilation error</code>) لأن <code dir="ltr">x</code> غير متاح للوصول إليه.</p>
                    <div class="answer false"><strong>الإجابة الصحيحة هي:</strong> a) Compiler Error because x is not accessible.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 42: استخدام Default Arguments في Function Prototype</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عند استخدام الوسائط الافتراضية (<code class="type">Default Arguments</code>) في دالة، يجب أن تكون جميع الوسائط التي تلي أول وسيط افتراضي هي أيضًا وسائط افتراضية.</p>
                    <p>في الإعلان <code dir="ltr">void myFunc(int x=3, int y)</code>، تم إعطاء قيمة افتراضية لـ <code dir="ltr">x</code> ولكن ليس لـ <code dir="ltr">y</code> الذي يليه. هذا غير صالح ويتسبب في خطأ في الترجمة.</p>
                    <div class="answer false"><strong>الإجابة الصحيحة هي:</strong> d) No, there should not be any arguments without default values to the right of the default arguments.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 43: وصول الكلاس المشتق لأعضاء الكلاس الأساسي</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلاس المشتق (<code class="keyword">derived class</code>) يمكنه الوصول مباشرة إلى الأعضاء العامة (<code class="keyword">public</code>) والمحمية (<code class="keyword">protected</code>) في الكلاس الأساسي (<code class="keyword">base class</code>).</p>
                    <p>لكنه لا يستطيع الوصول مباشرة إلى الأعضاء الخاصة (<code class="keyword">private</code>) في الكلاس الأساسي.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> a) The protected and public members of the base class.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 44: ترتيب تنفيذ Constructor لـ Embedded Object</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عندما يحتوي كلاس (<code class="keyword">X</code>) على كائن من كلاس آخر (<code class="keyword">Y</code>) كعضو بيانات (علاقة <code class="type">Composition</code>)، يتم دائمًا بناء الكائن المضمن (<code class="keyword">Y</code>) أولاً.</p>
                    <p>لذلك، يتم استدعاء <code class="keyword">constructor</code> الخاص بالكائن العضو (<code class="keyword">Y</code>) قبل تنفيذ جسم الـ <code class="keyword">constructor</code> الخاص بالكلاس الحاوي (<code class="keyword">X</code>).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> c) Before the body of the constructor of class X is executed.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 45: تعريف الـ Embedded (Aggregated) Object</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكائن المضمن أو المجمع (<code class="type">Embedded/Aggregated Object</code>) هو كائن يتم تضمينه كعضو بيانات داخل كلاس آخر. هذا يمثل علاقة "has-a" وهو أساس مفاهيم مثل <code class="type">Composition</code> و <code class="type">Aggregation</code>.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> b) An object that is included by another object.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 46: الـ Signature الصحيح لـ Copy Constructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الـ <code class="keyword">Copy Constructor</code> هو <code class="keyword">constructor</code> خاص يأخذ كائنًا من نفس الكلاس كوسيط. هذا الوسيط يجب أن يتم تمريره كمرجع ثابت (<code class="keyword">const reference</code>).</p>
                    <ul>
                        <li><b>Reference (&):</b> لتجنب استدعاء الـ copy constructor بشكل لانهائي.</li>
                        <li><b>Const:</b> لضمان أن الـ copy constructor لن يقوم بتعديل الكائن الأصلي الذي يتم نسخه.</li>
                    </ul>
                    <div class="answer"><strong>الـ Signature الصحيح هو:</strong> <code dir="ltr">Point(const Point&)</code>.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 47: توقع الـ Output لكود Pass by Reference و Copy Constructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدالة <code dir="ltr">show</code> تأخذ وسيطها كمرجع (<code dir="ltr">Nice &obj</code>). عند تمرير كائن بالمرجع، لا يتم إنشاء نسخة جديدة، وبالتالي <b>لا يتم استدعاء الـ <code class="keyword">Copy Constructor</code></b>.</p>
                    <ol>
                        <li><code dir="ltr">Nice n1;</code>: يستدعي الـ <code class="type">default constructor</code>.</li>
                        <li><code dir="ltr">n1.setA(15);</code>: يضبط قيمة <code dir="ltr">a</code> في <code dir="ltr">n1</code> إلى 15.</li>
                        <li><code dir="ltr">show(n1);</code>: يستدعي الدالة ويمرر <code dir="ltr">n1</code>. لا يحدث نسخ.</li>
                        <li>داخل <code dir="ltr">show</code>، يتم طباعة <code dir="ltr">obj.getA()</code>، وهي قيمة <code dir="ltr">a</code> في <code dir="ltr">n1</code>، أي 15.</li>
                    </ol>
                    <p>الإجابة <code dir="ltr">None of the above</code> في المستند قد تكون خاطئة، فالكود يجب أن يطبع 15.</p>
                    <div class="output"><strong>الـ Output الصحيح:</strong> 15.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 49: هل يمكن عمل Overloading للـ Destructor؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لا، لا يمكن إعادة تحميل المُدمِّرات (<code class="keyword">Destructors</code>) في C++.</p>
                    <p>كل كلاس يمكن أن يمتلك مُدمِّرًا واحدًا فقط، والذي له توقيع ثابت (<code dir="ltr">~ClassName()</code>) ولا يأخذ أي وسائط.</p>
                    <div class="answer false"><strong>العبارة "مينفعش يتعمله overload":</strong> صحيحة. العبارة في المستند خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 50: عبارات صحيحة عن الـ Constructors</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لنحلل العبارات:</p>
                    <ul>
                        <li><b>A. A constructor can be overloaded:</b> (يمكن إعادة تحميله) - <b>صحيح</b>.</li>
                        <li><b>B. A constructor is a special member function...:</b> (هو دالة خاصة بنفس اسم الكلاس) - <b>صحيح</b>.</li>
                        <li><b>C. A constructor can return a primitive...:</b> (يمكنه إرجاع قيمة) - <b>خطأ</b>. الـ Constructors لا تُرجع أي قيمة.</li>
                    </ul>
                    <div class="answer true"><strong>الإجابات الصحيحة هي:</strong> A, B.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 51: توقع الـ Output لكود Friend Function Access</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدالة <code dir="ltr">display</code> مُعلنة كـ <code class="keyword">friend</code> للكلاس <code class="keyword">Parent</code>، مما يمنحها حق الوصول إلى الأعضاء الخاصة (<code class="keyword">private</code>) والمحمية (<code class="keyword">protected</code>) في <code class="keyword">Parent</code>.</p>
                    <p>لكن المشكلة هنا هي في الكلاس <code class="keyword">Child</code>. المتغير <code dir="ltr">y</code> هو عضو خاص في <code class="keyword">Child</code>. والدالة <code dir="ltr">display</code> ليست <code class="keyword">friend</code> للكلاس <code class="keyword">Child</code>، لذا محاولتها الوصول إلى <code dir="ltr">c.y</code> ستؤدي إلى خطأ في الترجمة.</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compilation Error at Line 1, Child::y is inaccessible.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 52: خطوات لتشغيل كود Constructor Call و this</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكود به مشكلتان رئيسيتان:</p>
                    <ol>
                        <li><b>الوصول عبر <code class="keyword">this</code>:</b> في C++، <code class="keyword">this</code> هو مؤشر (<code class="keyword">pointer</code>)، لذا للوصول إلى الأعضاء نستخدم <code dir="ltr">-></code> (مثل <code dir="ltr">this->a</code>) أو نلغي الإشارة أولاً <code dir="ltr">(*this).a</code>. الصيغة <code dir="ltr">this.a</code> خاطئة.</li>
                        <li><b>استدعاء <code class="keyword">Constructor</code> الأساسي:</b> يجب استدعاء <code class="keyword">constructor</code> الكلاس الأساسي في قائمة التهيئة الخاصة بـ <code class="keyword">constructor</code> الكلاس المشتق، وليس في جسمه.</li>
                    </ol>
                    <div class="answer"><strong>التصحيح:</strong> استخدام <code dir="ltr">(*this).a</code> بدلاً من <code dir="ltr">this.a</code>، ونقل استدعاء <code dir="ltr">Super(5)</code> إلى قائمة التهيئة <code dir="ltr">Sub() : Super(5) {}</code>.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 53: توقع الـ Output لكود Constructor Call Order</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا السؤال يختبر ترتيب إنشاء الكائنات. (مكرر للسؤال 224).</p>
                    <ol>
                        <li><b><code dir="ltr">Base myBase;</code>:</b> تُنشئ كائن <code class="keyword">Base</code>، فيتم استدعاء الـ <code class="keyword">constructor</code> الخاص به ويطبع "Welcome".</li>
                        <li><b><code dir="ltr">Derived myDerived;</code>:</b> تُنشئ كائن <code class="keyword">Derived</code>. يتم استدعاء <code class="keyword">constructor</code> الـ <code class="keyword">Base</code> أولاً ("Welcome")، ثم <code class="keyword">constructor</code> الـ <code class="keyword">Derived</code> ("Hello").</li>
                    </ol>
                    <p>الناتج الإجمالي هو "Welcome" متبوعًا بـ "Welcome" ثم "Hello".</p>
                    <div class="output"><strong>الـ Output:</strong> Welcome Welcome Hello.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 55: وصول الـ Protected Member</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الأعضاء المحمية (<code class="keyword">protected</code>) في كلاس ما يمكن الوصول إليها مباشرة من داخل الكلاسات المشتقة منه (<code class="keyword">child classes</code>).</p>
                    <p>لذلك، إذا كان كلاس <code class="keyword">B</code> يرث من كلاس <code class="keyword">A</code>، فإن الدوال الأعضاء في <code class="keyword">B</code> يمكنها الوصول إلى الأعضاء المحمية في <code class="keyword">A</code>.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 56: وصف عملية Overriding</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>إعادة التعريف (<code class="keyword">Overriding</code>) تحدث عندما يقوم كلاس مشتق بتوفير تطبيق (<code class="keyword">implementation</code>) خاص به لدالة موجودة بالفعل في كلاس أساسي. هذا "يستبدل" وظيفة الدالة الأصلية بوظيفة جديدة خاصة بالكلاس المشتق.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> b) A function with the same name replaces the functionality of a function defined earlier in the inheritance hierarchy.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 57: ترتيب تنفيذ Constructor لـ Pointer to Embedded Object</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>السؤال غير كامل في المصدر. بشكل عام، إذا كان العضو المضمن مؤشرًا، فلن يتم استدعاء الـ <code class="keyword">constructor</code> الخاص به تلقائيًا. يجب عليك تخصيص الذاكرة له يدويًا (باستخدام <code class="keyword">new</code>) داخل <code class="keyword">constructor</code> الكلاس الحاوي.</p>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 58: توقع الـ Output لكود Protected Inheritance Access</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>تحليل الوراثة:</p>
                    <ul>
                        <li><code class="keyword">Child</code> يرث من <code class="keyword">Parent</code> بشكل <code class="keyword">protected</code>. هذا يجعل أعضاء <code class="keyword">Parent</code> العامة (<code class="keyword">public</code>) والمحمية (<code class="keyword">protected</code>) تصبح <code class="keyword">protected</code> في <code class="keyword">Child</code>.</li>
                        <li><code class="keyword">GrandChild</code> يرث من <code class="keyword">Child</code> بشكل <code class="keyword">public</code>. سيرث الأعضاء المحمية من <code class="keyword">Child</code> وستبقى <code class="keyword">protected</code> في <code class="keyword">GrandChild</code>.</li>
                    </ul>
                    <p>الكود المقدم لا يحتوي على استدعاءات فعلية، لذا لا يوجد output. السؤال يختبر فهم قواعد الوصول.</p>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 59: توقع الـ Output لكود Static Members</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكود غير موجود بالكامل، ولكن بناءً على تحليل المصدر:</p>
                    <ul>
                        <li><code dir="ltr">obj.x</code> (عضو كائن) ستكون قيمته 15.</li>
                        <li><code dir="ltr">myT.x</code> (عضو ثابت) ستكون قيمته 7.</li>
                        <li><code dir="ltr">Tester::var</code> (عضو ثابت آخر غير مهيأ) ستكون قيمته 0.</li>
                    </ul>
                    <div class="output"><strong>الـ Output هو:</strong> 15 7 0.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 60: تعريف الـ Composition</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>التكوين (<code class="type">Composition</code>) هو علاقة "has-a" قوية حيث يحتوي كلاس على كائن من كلاس آخر. السمة المميزة للتكوين هي أن دورة حياة الكائن المحتوى ("الجزء") مرتبطة بدورة حياة الكائن الحاوي ("الكل"). إذا تم تدمير "الكل"، يتم تدمير "الجزء" معه.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

        </div>
    </div>

     <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء الرابع: 61-80)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 61: عبارات صحيحة عن الـ Object Member Function</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدالة العضو للكائن (<code class="keyword">Object Member Function</code>) هي دالة غير ثابتة (<code class="keyword">non-static</code>). لنحلل العبارات:</p>
                    <ul>
                        <li><b>A:</b> "يمكن استدعاؤها باستخدام اسم الكلاس" - <b>خطأ</b>. يجب استدعاؤها عبر كائن.</li>
                        <li><b>B:</b> "لديها مؤشر 'this' ضمني" - <b>صحيح</b>.</li>
                        <li><b>C:</b> "تستقبل 'this' كوسيط ضمني" - <b>صحيح</b>.</li>
                        <li><b>D:</b> "يمكنها الوصول إلى متغيرات الكائن (instance variables)" - <b>صحيح</b>.</li>
                        <li><b>E:</b> "لا يمكن إعادة تحميلها" - <b>خطأ</b>. يمكن إعادة تحميلها.</li>
                        <li><b>F:</b> "يمكنها استدعاء دوال عضو أخرى" - <b>صحيح</b>.</li>
                    </ul>
                    <div class="answer true"><strong>الإجابات الصحيحة هي:</strong> B, C, D, F.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 62: صحة Function Prototype مع Default Arguments</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>القاعدة هي: إذا تم إعطاء وسيط قيمة افتراضية، فيجب إعطاء جميع الوسائط التي تليه قيمًا افتراضية أيضًا.</p>
                    <p>الإعلان <code dir="ltr">void myFunc(int myDef=17, int myVar, int myNormalVar=5)</code> غير صالح لأن <code dir="ltr">myVar</code> ليس له قيمة افتراضية وهو يقع بين وسيطين لهما قيم افتراضية.</p>
                    <div class="answer false"><strong>العبارة:</strong> الإعلان غير صحيح.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 63: تعديل الـ Static Member Variable</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "يمكن تعديل المتغيرات الثابتة فقط بواسطة الدوال الثابتة" هي عبارة <b>خاطئة</b>.</p>
                    <p>المتغيرات الثابتة (<code class="keyword">Static variables</code>) تنتمي للكلاس نفسه وليس لكائن معين. يمكن الوصول إليها وتعديلها من:</p>
                    <ul>
                        <li>الدوال الثابتة (<code class="keyword">static member functions</code>).</li>
                        <li>الدوال غير الثابتة (<code class="keyword">non-static member functions</code>).</li>
                    </ul>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 65: توقع الـ Output لكود Parent & Child Constructor Access</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>سيحدث خطأ في الترجمة (<code class="type">Compilation Error</code>) لعدة أسباب:</p>
                    <ol>
                        <li><b>Line 1:</b> الـ <code class="keyword">constructor</code> الخاص بـ <code class="keyword">Parent</code> هو <code class="keyword">private</code> افتراضيًا، والكلاس <code class="keyword">Child</code> يحاول استدعاءه ضمنيًا مما يسبب خطأ وصول.</li>
                        <li><b>Line 2:</b> الكلاس <code class="keyword">Child</code> لا يحتوي على <code class="keyword">constructor</code> يطابق الاستدعاء <code dir="ltr">Child(2, 3)</code>.</li>
                        <li><b>Line 3:</b> المتغير <code dir="ltr">x</code> هو <code class="keyword">private</code> في <code class="keyword">Parent</code>، ولا يمكن الوصول إليه من <code class="keyword">main</code>.</li>
                    </ol>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compiler Error في الأسطر 1, 2, 3.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 66: توقع الـ Output لكود Virtual vs. Non-Virtual Functions</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكود يوضح الفرق بين الربط الثابت والديناميكي.</p>
                    <ul>
                        <li><b><code dir="ltr">(*pointer).powerTwo()</code>:</b> الدالة <code dir="ltr">powerTwo</code> غير افتراضية (<code class="keyword">non-virtual</code>). يتم تحديد النسخة التي سيتم استدعاؤها في وقت الترجمة بناءً على نوع المؤشر (<code dir="ltr">Parent*</code>). لذا، يتم استدعاء نسخة <code class="keyword">Parent</code> وتطبع 4 (<code dir="ltr">2*2</code>).</li>
                        <li><b><code dir="ltr">myPtr->powerThree()</code>:</b> الدالة <code dir="ltr">powerThree</code> افتراضية (<code class="keyword">virtual</code>). يتم تحديد النسخة في وقت التشغيل بناءً على نوع الكائن الفعلي الذي يشير إليه المؤشر (<code class="keyword">Child</code>). لذا، يتم استدعاء نسخة <code class="keyword">Child</code> وتطبع 27 (<code dir="ltr">3*3*3</code>).</li>
                    </ul>
                    <div class="output"><strong>الـ Output هو:</strong> 4 27.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 67: توقع الـ Output لكود Static Member Initialization & Constructor Overload</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>السؤال غير مكتمل في المصدر، لكنه يشير إلى وجود خطأ ترجمة (<code class="type">Compilation Error</code>). غالبًا ما يكون الخطأ مرتبطًا بقواعد إعادة التحميل (<code class="keyword">overloading</code>) أو تهيئة الأعضاء الثابتة (<code class="keyword">static members</code>).</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compilation Error.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 68: تعريف الـ Default Constructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الـ <code class="keyword">constructor</code> الافتراضي (<code class="type">Default Constructor</code>) هو <code class="keyword">constructor</code> يمكن استدعاؤه بدون أي وسائط. إذا لم يقم المبرمج بتعريف أي <code class="keyword">constructor</code> على الإطلاق، فإن المترجم يقوم بإنشاء واحد افتراضي فارغ تلقائيًا.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 69: أسهل خطأ يمكن اكتشافه</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>أسهل أنواع الأخطاء التي يمكن اكتشافها هي أخطاء الترجمة (<code class="type">Compilation errors</code>)، والتي تُعرف أيضًا بالأخطاء النحوية (<code class="type">syntax errors</code>).</p>
                    <p>يكتشفها المترجم (<code class="keyword">compiler</code>) قبل تشغيل البرنامج، وغالبًا ما يقدم رسائل خطأ واضحة مع رقم السطر، مما يسهل تحديدها وإصلاحها.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Compilation error or syntax error.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 70: إعلان متغير غير صالح</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الخيار <code dir="ltr">#define PI 3.14</code> ليس إعلانًا لمتغير. إنه توجيه للمعالج الأولي (<code class="type">preprocessor directive</code>) يقوم باستبدال كل مثيل لـ <code dir="ltr">PI</code> بالنص <code dir="ltr">3.14</code> قبل عملية الترجمة. الخيارات الأخرى هي إعلانات صحيحة لمتغيرات.</p>
                    <div class="answer"><strong>الإعلان غير الصالح كمتغير هو:</strong> <code dir="ltr">#define PI 3.14</code>.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 71: حجم نوع البيانات int</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>معيار لغة C/C++ لا يحدد حجمًا ثابتًا لنوع البيانات <code class="type">int</code>. بدلاً من ذلك، يضمن حدًا أدنى للنطاق الذي يجب أن يدعمه.</p>
                    <p>الحجم الفعلي لـ <code class="type">int</code> يعتمد على النظام (<code class="keyword">system</code>)، بما في ذلك بنية المعالج (<code class="keyword">architecture</code>) والمترجم (<code class="keyword">compiler</code>) المستخدم.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Depends on the system/compiler.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 72: تشغيل ملف C على أنظمة تشغيل مختلفة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عملية الترجمة (<code class="keyword">compilation</code>) تُنشئ ملفًا تنفيذيًا (<code class="type">executable file</code>) مصممًا خصيصًا لبنية نظام التشغيل (<code class="keyword">OS architecture</code>) الذي تم تجميعه عليه.</p>
                    <p>ملف تنفيذي تم إنشاؤه على Windows لن يعمل مباشرة على macOS أو Linux. يجب إعادة ترجمة الكود المصدري (<code class="keyword">source code</code>) على كل نظام لتوليد ملف تنفيذي متوافق.</p>
                    <div class="answer false"><strong>العبارة "مينفعش يشتغل مباشرة":</strong> صحيحة، مما يجعل العبارة في المستند خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 73: توقع الـ Output لكود Type Casting</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عند جمع <code class="type">int</code> (<code dir="ltr">a=10</code>) مع <code class="type">double</code> (<code dir="ltr">b=5.6</code>)، يتم ترقية الـ <code class="type">int</code> إلى <code class="type">double</code> قبل الجمع. الناتج يكون <code class="type">double</code>: <code dir="ltr">15.6</code>.</p>
                    <p>عند إسناد هذه القيمة (<code dir="ltr">15.6</code>) إلى متغير من نوع <code class="type">int</code> (<code dir="ltr">c</code>)، يتم اقتطاع الجزء العشري (<code class="type">truncation</code>).</p>
                    <div class="output"><strong>الـ Output هو:</strong> 15.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 74: تنظيم الكود ومنع تضارب الأسماء</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الـ <code class="keyword">Namespaces</code> هي ميزة في C++ تُستخدم لتنظيم الكود في مجموعات منطقية ومنع تضارب الأسماء (<code class="type">name collisions</code>) الذي قد يحدث عند استخدام مكتبات متعددة تعرف نفس الأسماء للمعرفات (<code class="keyword">identifiers</code>) مثل الدوال والمتغيرات.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Namespaces.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 75: أنواع البيانات الجديدة في C++ مقارنة بـ C</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لغة C++ قدمت العديد من الميزات الجديدة فوق لغة C، بما في ذلك أنواع بيانات جديدة. من أبرزها:</p>
                    <ul>
                        <li><code class="type">bool</code>: لتمثيل القيم المنطقية (true/false).</li>
                        <li><code class="type">std::string</code>: كلاس قوي ومناسب للتعامل مع السلاسل النصية، وهو جزء من المكتبة القياسية.</li>
                    </ul>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> B and C (bool and string).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 76: توقع الـ Output لكود Octal Number</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>في لغة C/C++، أي عدد صحيح يبدأ بصفر (<code dir="ltr">0</code>) يُعتبر رقمًا ثمانيًا (<code class="type">octal</code>)، أي أساسه 8.</p>
                    <p>الرقم <code dir="ltr">010</code> بالنظام الثماني يعادل <code dir="ltr">(1 * 8^1) + (0 * 8^0)</code>، وهو ما يساوي <code dir="ltr">8 + 0 = 8</code> بالنظام العشري.</p>
                    <div class="output"><strong>الـ Output هو:</strong> 8.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 77: توقع الـ Output لكود تهيئة Const Variable</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>المتغيرات الثابتة (<code class="keyword">const</code>) يجب أن يتم تهيئتها (<code class="keyword">initialized</code>) عند تعريفها. لا يمكنك تعريف متغير <code class="keyword">const</code> ثم محاولة إسناد قيمة له في سطر لاحق.</p>
                    <p>الكود الذي يحاول فعل ذلك سيؤدي إلى خطأ في الترجمة (<code class="type">compile-time error</code>).</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compile time error.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 78: توقع الـ Output لكود Relational Expression</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>التعبير العلائقي (<code class="type">Relational Expression</code>) مثل <code dir="ltr">a == (b + c)</code> يُقيّم إلى قيمة منطقية.</p>
                    <ul>
                        <li><code dir="ltr">b + c</code> يساوي <code dir="ltr">3 + 7 = 10</code>.</li>
                        <li><code dir="ltr">a</code> قيمتها 10.</li>
                        <li>المقارنة <code dir="ltr">10 == 10</code> تكون نتيجتها <code class="keyword">true</code>.</li>
                    </ul>
                    <p>في لغة C، القيمة <code class="keyword">true</code> تُمثل بالرقم 1. لذلك، سيتم إسناد القيمة 1 إلى المتغير <code dir="ltr">d</code>.</p>
                    <div class="output"><strong>الـ Output هو:</strong> 1.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 79: القيمة النهائية لمتغير في كود به Operator Precedence</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>بسبب أسبقية المعاملات (<code class="type">Operator Precedence</code>)، يتم تنفيذ عملية الجمع (<code dir="ltr">+</code>) قبل عملية المقارنة (<code dir="ltr">==</code>).</p>
                    <ul>
                        <li><code dir="ltr">b + c</code> يُحسب أولاً، والناتج هو 10.</li>
                        <li>ثم تتم مقارنة <code dir="ltr">a == 10</code>. بما أن <code dir="ltr">a</code> تساوي 10، فإن نتيجة المقارنة هي <code class="keyword">true</code> (تُمثل بـ 1).</li>
                        <li>يتم إسناد القيمة 1 إلى المتغير <code dir="ltr">d</code>.</li>
                    </ul>
                    <div class="answer"><strong>القيمة النهائية لـ d هي:</strong> 1.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 80: استخدام Scope Resolution Operator</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>معامل تحديد النطاق (<code dir="ltr">::</code>) يُستخدم للوصول إلى أعضاء النطاقات بشكل صريح. أحد استخداماته الشائعة هو الوصول إلى متغير عام (<code class="type">global variable</code>) عندما يكون هناك متغير محلي (<code class="type">local variable</code>) بنفس الاسم يحجبه.</p>
                    <p>باستخدام <code dir="ltr">::variableName</code>، فإنك تخبر المترجم صراحةً أنك تريد استخدام النسخة العامة من المتغير.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Scope resolution operator (::).</div>
                </div>
            </div>

        </div>
    </div>


       <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء الخامس: 81-100)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 81: توقع الـ Output لكود Logical Operators & Short-circuiting</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لنحلل التعبير <code dir="ltr">a = (x && y) || ++z;</code> مع الأخذ في الاعتبار أسبقية المعاملات والتقييم المختصر.</p>
                    <ol>
                        <li><b><code dir="ltr">(x && y)</code>:</b> المعامل <code dir="ltr">&&</code> له أسبقية أعلى من <code dir="ltr">||</code>. <code dir="ltr">x</code> قيمتها 1 (<code class="keyword">true</code>)، و <code dir="ltr">y</code> قيمتها 0 (<code class="keyword">false</code>). إذن، <code dir="ltr">true && false</code> نتيجتها <code class="keyword">false</code> (0).</li>
                        <li><b><code dir="ltr">(false) || ++z</code>:</b> الآن التعبير أصبح <code dir="ltr">0 || ++z</code>. بما أن الطرف الأيسر لـ <code dir="ltr">||</code> هو <code class="keyword">false</code>، يجب تقييم الطرف الأيمن (لا يوجد تقييم مختصر هنا).</li>
                        <li><b><code dir="ltr">++z</code>:</b> يتم زيادة <code dir="ltr">z</code> أولاً (تصبح 6)، ثم تُستخدم قيمتها الجديدة. القيمة 6 تُعتبر <code class="keyword">true</code> في سياق منطقي.</li>
                        <li><b><code dir="ltr">false || true</code>:</b> النتيجة النهائية هي <code class="keyword">true</code>، والتي تُمثل بالرقم 1.</li>
                        <li><b><code dir="ltr">a = 1</code>:</b> يتم إسناد القيمة 1 إلى <code dir="ltr">a</code>.</li>
                    </ol>
                    <div class="output"><strong>الـ Output هو:</strong> <code dir="ltr">a=1 z=6</code>.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 82: حجم الـ Pointers على 32-bit machine</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>المعامل <code class="keyword">sizeof</code> عند تطبيقه على مؤشر (<code class="keyword">pointer</code>) يُرجع حجم المؤشر نفسه، وليس حجم البيانات التي يشير إليها.</p>
                    <p>على نظام بمعمارية 32-بت، يكون حجم العنوان في الذاكرة 32 بت، وهو ما يعادل 4 بايت (<code dir="ltr">32 / 8 = 4</code>). لذلك، حجم أي مؤشر (بغض النظر عن نوع البيانات الذي يشير إليه) هو 4 بايت.</p>
                    <div class="output"><strong>الـ Output هو:</strong> p and q are 4 and 4.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 83: المعامل المستخدم لـ Dynamic Memory Allocation</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>في C++، المعامل القياسي المستخدم لتخصيص الذاكرة ديناميكيًا (على الكومة <code class="keyword">heap</code>) هو <code class="keyword">new</code>.</p>
                    <p>يقوم <code class="keyword">new</code> بحجز الذاكرة المطلوبة ويستدعي الـ <code class="keyword">constructor</code> المناسب للكائن.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> new.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 84: إنشاء Variable-length Array في C++</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>المصفوفات القياسية في C++ يجب أن يكون حجمها ثابتًا ومعروفًا في وقت الترجمة. لإنشاء مصفوفة يتحدد حجمها في وقت التشغيل (<code class="keyword">runtime</code>)، يجب استخدام تخصيص الذاكرة الديناميكي.</p>
                    <p>الطريقة الصحيحة لفعل ذلك هي باستخدام المعامل <code class="keyword">new</code>. على سبيل المثال، لإنشاء مصفوفة من الأعداد الصحيحة، نستخدم <code dir="ltr">new int[n]</code>.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> <code dir="ltr">new int[n]</code>. (المستند يذكر <code dir="ltr">int *</code>، وهو نوع المؤشر الذي سيحمل العنوان، لكن عملية الإنشاء نفسها تتم بـ <code class="keyword">new</code>).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 85: توقع الـ Output لكود Pointer Increment & Dereference</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>في التعبير <code dir="ltr">*p++</code>، معامل الزيادة اللاحقة (<code dir="ltr">++</code> postfix) له أسبقية أعلى من معامل إلغاء الإشارة (<code dir="ltr">*</code> dereference)، ولكن التقييم يحدث بشكل مختلف.</p>
                    <p>التعبير يُفسر على أنه <code dir="ltr">*(p++)</code>. هذا يعني:</p>
                    <ol>
                        <li>احصل على القيمة الحالية للمؤشر <code dir="ltr">p</code>.</li>
                        <li>قم بإلغاء الإشارة إلى هذه القيمة (<code dir="ltr">*p</code>) واستخدمها في التعبير (للطباعة). سيتم طباعة 10.</li>
                        <li>بعد اكتمال التعبير، قم بزيادة المؤشر <code dir="ltr">p</code> ليشير إلى العنصر التالي في الذاكرة.</li>
                    </ol>
                    <div class="output"><strong>الـ Output هو:</strong> 10.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 86: تعريف عملية PUSH في الـ Stack</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الوصف يشرح عملية الإضافة إلى مكدس (<code class="keyword">Stack</code>) مبني باستخدام قائمة مرتبطة (<code class="type">linked list</code>).</p>
                    <p>عملية إضافة عنصر جديد إلى قمة المكدس تُعرف باسم <code class="type">PUSH</code>. تتضمن إنشاء عقدة جديدة، جعلها تشير إلى القمة القديمة، ثم تحديث مؤشر القمة ليشير إلى العقدة الجديدة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> PUSH.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 87: الـ Operator Overloading في كلاس <code>std::string</code></span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>كلاس <code class="type">std::string</code> في C++ يقوم بإعادة تحميل العديد من المعاملات لتسهيل التعامل معه بشكل بديهي، مثل:</p>
                    <ul>
                        <li><b><code dir="ltr">=</code>:</b> للإسناد (Assignment).</li>
                        <li><b><code dir="ltr">==, >, <</code>:</b> للمقارنة (Comparison).</li>
                        <li><b><code dir="ltr">+</code>:</b> لدمج السلاسل (Concatenation).</li>
                    </ul>
                    <p>كل الخيارات المذكورة هي أمثلة صحيحة على إعادة تحميل المعاملات في هذا الكلاس.</p>
                    <div class="answer true"><strong>الإجابة الصحيحة هي:</strong> كل الـ statements المذكورة تستخدم operator overloading.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 88: تعريف الـ Inline Function</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدالة المضمنة (<code class="keyword">Inline Function</code>) هي طلب أو اقتراح للمترجم (<code class="keyword">compiler</code>) بأن يقوم باستبدال استدعاء الدالة بجسم الدالة الفعلي مباشرة في الكود.</p>
                    <p>الهدف من ذلك هو تجنب التكلفة الإضافية (<code class="type">overhead</code>) لعملية استدعاء الدالة، مما قد يؤدي إلى تحسين الأداء (optimization)، خصوصًا للدوال الصغيرة التي يتم استدعاؤها بشكل متكرر.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Inline function.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 89: ما الذي لا يجب أن تحتويه الـ Inline Functions</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلمة المفتاحية <code class="keyword">inline</code> هي مجرد اقتراح. المترجم قد يتجاهلها إذا كانت الدالة معقدة جدًا، لأن تضمينها قد يزيد من حجم الكود التنفيذي دون تحسين الأداء.</p>
                    <p>الحالات التي يتجنب فيها المترجم التضمين تشمل الدوال التي تحتوي على:</p>
                    <ul>
                        <li>حلقات تكرار (<code class="keyword">loops</code>).</li>
                        <li>متغيرات ثابتة (<code class="keyword">static variables</code>).</li>
                        <li>استدعاء ذاتي (<code class="keyword">recursion</code>).</li>
                        <li>جمل <code class="keyword">switch</code>.</li>
                    </ul>
                    <div class="answer true"><strong>الإجابة الصحيحة هي:</strong> All of the above.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 90: تعريف الـ Function Overloading</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>إعادة تحميل الدوال (<code class="keyword">Function Overloading</code>) هي ميزة تسمح بتعريف دالتين أو أكثر بنفس الاسم في نفس النطاق، طالما أن قوائم وسائطهما (<code class="keyword">parameters</code>) مختلفة.</p>
                    <p>هذا يعتبر شكلاً من أشكال تعدد الأشكال في وقت الترجمة (<code class="type">compile-time polymorphism</code>).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> overloaded.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 91: تعريف الـ Default Arguments</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الوسائط الافتراضية (<code class="type">Default Arguments</code>) هي قيم يتم تعيينها لوسائط الدالة في تعريفها. إذا لم يقم المستدعي بتمرير قيمة لهذه الوسائط عند استدعاء الدالة، فسيتم استخدام القيم الافتراضية تلقائيًا.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Default Arguments.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 92: مزايا الـ OOP</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>البرمجة كائنية التوجه (OOP) تقدم العديد من المزايا:</p>
                    <ul>
                        <li><b><code class="type">Abstraction</code>:</b> إخفاء تفاصيل التنفيذ المعقدة.</li>
                        <li><b><code class="type">Inheritance</code>:</b> إعادة استخدام الكود.</li>
                        <li><b><code class="type">Encapsulation</code>:</b> زيادة الأمان وحماية البيانات.</li>
                    </ul>
                    <p>كل هذه المفاهيم تهدف إلى محاكاة كيانات العالم الحقيقي في البرمجة.</p>
                    <div class="answer true"><strong>الإجابة:</strong> كل الخيارات المذكورة هي من مزايا OOP.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 93: تعريف الـ Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الـ <code class="keyword">Class</code> هو نوع بيانات مُعرَّف من قبل المستخدم (<code class="type">user-defined data type</code>). يعمل كمخطط (<code class="type">blueprint</code>) لإنشاء الكائنات (<code class="keyword">objects</code>).</p>
                    <p>يقوم بتجميع البيانات (المتغيرات الأعضاء <code class="keyword">data members</code>) والدوال التي تعمل على هذه البيانات (الدوال الأعضاء <code class="keyword">member functions</code>) في وحدة واحدة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Class.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 94: إعلان غير صالح لـ Pointer</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لنحلل الإعلانات:</p>
                    <ul>
                        <li><b><code dir="ltr">char a;</code>:</b> إعلان صحيح لمتغير من نوع <code class="type">char</code>، وليس مؤشر.</li>
                        <li><b><code dir="ltr">char a[];</code>:</b> إعلان لمصفوفة من نوع <code class="type">char</code>.</li>
                        <li><b><code dir="ltr">char *str;</code>:</b> إعلان صحيح لمؤشر من نوع <code class="type">char</code>.</li>
                    </ul>
                    <p>السؤال يبحث عن إعلان غير صالح لمؤشر. الإعلان <code dir="ltr">char a;</code> هو إعلان صالح لمتغير وليس لمؤشر، مما يجعله الإجابة المقصودة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> <code dir="ltr">char a;</code>.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 95: توقع الـ Output لكود Rvalue Error</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>نتيجة عملية باقي القسمة (<code dir="ltr">%</code>) هي قيمة مؤقتة تُعرف بـ <code class="type">rvalue</code> (قيمة يمينية).</p>
                    <p>معامل الزيادة (<code dir="ltr">++</code>) يتطلب معاملًا يمكن تعديله، يُعرف بـ <code class="type">lvalue</code> (قيمة يسارية)، وهو متغير له موقع في الذاكرة. لا يمكنك تطبيق معامل الزيادة على قيمة مؤقتة.</p>
                    <p>محاولة القيام بذلك ستؤدي إلى خطأ في الترجمة (<code class="type">compile-time error</code>).</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compile time error.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 96: تعريف الـ Object</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكائن (<code class="keyword">Object</code>) هو مثيل (<code class="type">instance</code>) من كلاس (<code class="keyword">Class</code>). إنه كيان ملموس يتم إنشاؤه بناءً على المخطط الذي يوفره الكلاس.</p>
                    <p>يمتلك الكائن نسخته الخاصة من متغيرات البيانات، ويمكنك استدعاء دواله الأعضاء من خلاله.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Object.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 97: الأركان الأربعة للـ OOP</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الأركان أو المبادئ الأساسية الأربعة للبرمجة كائنية التوجه (OOP) هي:</p>
                    <ul>
                        <li><b>Encapsulation (التغليف)</b></li>
                        <li><b>Abstraction (التجريد)</b></li>
                        <li><b>Inheritance (الوراثة)</b></li>
                        <li><b>Polymorphism (تعدد الأشكال)</b></li>
                    </ul>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Encapsulation, Abstraction, Inheritance, Polymorphism.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 98: تعريف الـ Abstraction</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>التجريد (<code class="type">Abstraction</code>) هو عملية إخفاء تفاصيل التنفيذ المعقدة وعرض الوظائف الأساسية فقط للمستخدم.</p>
                    <p>يهدف إلى تبسيط الأنظمة المعقدة عن طريق نمذجة الكلاسات بواجهات (<code class="keyword">interfaces</code>) واضحة وسهلة الاستخدام، دون الحاجة إلى القلق بشأن كيفية عملها داخليًا.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Abstraction.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 99: تعريف الـ private Keyword</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلمة المفتاحية <code class="keyword">private</code> هي محدد وصول (<code class="type">access specifier</code>) يجعل الأعضاء التي تليها لا يمكن الوصول إليها إلا من داخل دوال الكلاس نفسه.</p>
                    <p>هذا يوفر أعلى مستوى من الحماية ويمنع الوصول المباشر أو التعديل من خارج الكلاس، وهو جزء أساسي من مبدأ التغليف (<code class="type">Encapsulation</code>).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> private.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 100: تخصيص الذاكرة للـ Class و الـ Object</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عند تعريف كلاس (<code class="keyword">Class</code>)، لا يتم تخصيص أي ذاكرة. الكلاس هو مجرد قالب أو مخطط.</p>
                    <p>يتم تخصيص الذاكرة فقط عند إنشاء مثيل (<code class="type">instance</code>) من هذا الكلاس، أي عند إنشاء كائن (<code class="keyword">Object</code>).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> لا يتم تخصيص الذاكرة للـ Class، بل للـ Object.</div>
                </div>
            </div>

        </div>
    </div>


        <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء السادس: 101-120)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 101: تعريف الـ Class (Blueprint)</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الـ <code class="keyword">Class</code> هو مخطط (<code class="type">blueprint</code>) أو قالب (<code class="type">template</code>) يحدد المتغيرات (<code class="keyword">variables</code>) والدوال (<code class="keyword">methods</code>) المشتركة لمجموعة من الكائنات.</p>
                    <p>كل كائن (<code class="keyword">object</code>) يتم إنشاؤه من هذا الكلاس يكون له حالته (<code class="keyword">state</code>) الخاصة به (قيم متغيراته)، ولكنه يشارك نفس البنية (<code class="keyword">structure</code>) والسلوك (<code class="keyword">behaviors</code>) المحددة في الكلاس.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Class.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 102: تعريف الـ Data Hiding</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>إخفاء البيانات (<code class="type">Data Hiding</code>) هو مبدأ يتم تحقيقه عادةً عن طريق جعل أعضاء البيانات في الكلاس <code class="keyword">private</code>.</p>
                    <p>هذا يعني أنه لا يمكن الوصول إلى هذه البيانات مباشرة من خارج الكلاس. الطريقة الوحيدة للتفاعل معها هي من خلال الدوال الأعضاء العامة (<code class="keyword">public member functions</code>) للكلاس نفسه. هذا جزء أساسي من التغليف (<code class="type">Encapsulation</code>).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> data hiding.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 103: تعريف الـ Constructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الـ <code class="keyword">Constructor</code> هو دالة عضو خاصة في الكلاس وظيفتها الأساسية هي تهيئة (<code class="keyword">initialize</code>) الكائن عند إنشائه. يتم استدعاؤه تلقائيًا لضمان أن الكائن يبدأ في حالة صالحة وصحيحة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Constructor.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 104: الفرق بين Constructor و Normal Method</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الـ <code class="keyword">Constructor</code> يختلف عن الدوال العادية في عدة نقاط رئيسية:</p>
                    <ul>
                        <li>له نفس اسم الكلاس بالضبط.</li>
                        <li>لا يُرجع أي قيمة، ولا حتى <code class="keyword">void</code>.</li>
                        <li>يتم استدعاؤه تلقائيًا عند إنشاء كائن، لا يمكنك استدعاؤه بشكل صريح.</li>
                    </ul>
                    <div class="answer true"><strong>الإجابة الصحيحة هي:</strong> All of the above.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 105: تعريف الـ Constructor Overloading</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>إعادة تحميل المُنشئ (<code class="type">Constructor Overloading</code>) هي نفس فكرة إعادة تحميل الدوال. تعني وجود أكثر من <code class="keyword">constructor</code> في نفس الكلاس، كل منها له قائمة وسائط (<code class="keyword">list of arguments</code>) مختلفة.</p>
                    <p>هذا يسمح بإنشاء وتهيئة الكائنات بطرق متعددة ومختلفة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Constructor Overloading.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 106: تعريف الـ Copy Constructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>مُنشئ النسخ (<code class="type">Copy Constructor</code>) هو دالة عضو خاصة تُستخدم لتهيئة كائن جديد كنسخة من كائن موجود بالفعل من نفس الكلاس. يتم استدعاؤه تلقائيًا في حالات مثل تمرير كائن بالقيمة أو إرجاع كائن من دالة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Copy Constructor.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 107: مثال على Initializer List</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>قائمة التهيئة (<code class="type">Initializer List</code>) هي طريقة لتهيئة أعضاء البيانات في الكلاس. تأتي بعد قائمة وسائط الـ <code class="keyword">constructor</code>، مفصولة بنقطتين رأسيتين (<code dir="ltr">:</code>).</p>
                    <p>تعتبر هذه الطريقة أكثر كفاءة من الإسناد داخل جسم الـ <code class="keyword">constructor</code>، وهي ضرورية لتهيئة الأعضاء الثابتة (<code class="keyword">const</code>) وأعضاء المرجع (<code class="keyword">reference</code>).</p>
                    <div class="answer"><strong>المثال الصحيح هو:</strong> <code dir="ltr">Point(int i, int j) : x(i), y(j) {}</code>.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 108: تعريف الـ Deep Copy</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>النسخ العميق (<code class="type">Deep Copy</code>) ضروري عندما يحتوي الكائن على مؤشرات تشير إلى ذاكرة مخصصة ديناميكيًا.</p>
                    <p>بدلاً من مجرد نسخ عنوان المؤشر (كما يفعل النسخ السطحي)، يقوم النسخ العميق بتخصيص ذاكرة جديدة للكائن المنسوخ ثم ينسخ المحتوى من الذاكرة الأصلية إلى الذاكرة الجديدة. هذا يضمن أن كل كائن له موارده الخاصة والمستقلة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Deep Copy.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 109: تعريف الـ Shallow Copy</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>النسخ السطحي (<code class="type">Shallow Copy</code>) يقوم بنسخ قيم أعضاء البيانات كما هي (نسخ bit-wise). يعمل بشكل جيد مع أنواع البيانات البسيطة.</p>
                    <p>لكن عند التعامل مع المؤشرات، فإنه ينسخ عنوان الذاكرة فقط، وليس البيانات التي يشير إليها. هذا يؤدي إلى أن الكائن الأصلي والمنسوخ يشيران إلى نفس الموقع في الذاكرة، مما قد يسبب مشاكل مثل الحذف المزدوج (<code class="type">double free</code>).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Shallow Copy.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 110: تعريف الـ Friend Function</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدالة الصديقة (<code class="type">Friend Function</code>) هي دالة يتم تعريفها خارج نطاق الكلاس، ولكن يتم منحها إذنًا خاصًا للوصول إلى الأعضاء الخاصة (<code class="keyword">private</code>) والمحمية (<code class="keyword">protected</code>) في هذا الكلاس.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> friend function.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 111: استخدام شائع لـ Friend Function</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>أحد الاستخدامات الشائعة والجيدة للدوال الصديقة هو عندما تحتاج إلى إجراء عملية تتطلب الوصول إلى الأعضاء الداخلية لكائنين من كلاسات مختلفة (أو من نفس الكلاس).</p>
                    <p>على سبيل المثال، دالة مقارنة تحتاج إلى الوصول إلى أعضاء خاصة في كائنين لمقارنتهما هي مرشح مثالي لتكون دالة صديقة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> friend function.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 112: تعريف الـ Forward Declarations</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الإعلانات الأمامية (<code class="type">Forward Declarations</code>) هي طريقة لإخبار المترجم بوجود كلاس قبل تعريفه بالكامل (مثل <code dir="ltr">class MyClass;</code>).</p>
                    <p>هذا ضروري لحل مشكلة الاعتماديات الدائرية (<code class="type">circular dependencies</code>) بين الكلاسات، أو عندما تحتاج فقط إلى استخدام مؤشرات أو مراجع لهذا الكلاس دون الحاجة إلى معرفة تفاصيله الكاملة بعد.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Forward declarations.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 113: وصول الـ Static Function لأعضاء الكلاس</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدوال الثابتة (<code class="keyword">Static Function</code>) تنتمي إلى الكلاس نفسه، وليس إلى كائن معين. لهذا السبب، ليس لديها مؤشر <code class="keyword">this</code>.</p>
                    <p>ونتيجة لذلك، لا يمكنها الوصول مباشرة إلى الأعضاء غير الثابتة (بيانات أو دوال عادية). يمكنها فقط الوصول إلى الأعضاء الثابتة الأخرى (بيانات أو دوال) في نفس الكلاس.</p>
                    <div class="answer false"><strong>العبارة "متقدرش توصل لـ ...":</strong> صحيحة.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 114: أنواع الـ Overloading في C++</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>توفر لغة C++ نوعين رئيسيين من إعادة التحميل (<code class="keyword">overloading</code>):</p>
                    <ul>
                        <li><b>Function Overloading:</b> تعريف دوال متعددة بنفس الاسم ولكن بقوائم وسائط مختلفة.</li>
                        <li><b>Operator Overloading:</b> إعادة تعريف سلوك المعاملات (مثل +, -, *) للعمل مع أنواع البيانات المخصصة.</li>
                    </ul>
                    <div class="answer true"><strong>الإجابة الصحيحة هي:</strong> A & C.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 115: تعريف الـ Operator Overloading</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>إعادة تحميل المعامل (<code class="type">Operator Overloading</code>) هي ميزة في C++ تسمح بإعطاء معنى جديد أو سلوك مخصص للمعاملات القياسية (مثل <code dir="ltr">+</code>, <code dir="ltr">-</code>, <code dir="ltr">==</code>, إلخ) عند استخدامها مع كائنات من كلاسات قمت بتعريفها.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Operator overloading.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 116: الـ Binary Operators Overloading كـ Member Function</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عند إعادة تحميل معامل ثنائي (<code class="type">binary operator</code>) كدالة عضو، فإن الكائن الموجود على يسار المعامل يتم تمريره ضمنيًا عبر مؤشر <code class="keyword">this</code>.</p>
                    <p>لذلك، تحتاج الدالة العضو إلى وسيط صريح واحد فقط (<code class="type">one explicit argument</code>) لتمثيل الكائن الموجود على يمين المعامل.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> one explicit argument.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 117: موضع الـ Unary Operators Overloading</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "المعامل الأحادي يظهر دائمًا على يمين الكائن" هي <b>خاطئة</b>.</p>
                    <p>المعاملات الأحادية يمكن أن تكون:</p>
                    <ul>
                        <li><b>Prefix (قبل الكائن):</b> مثل <code dir="ltr">++x</code>.</li>
                        <li><b>Postfix (بعد الكائن):</b> مثل <code dir="ltr">x++</code>.</li>
                    </ul>
                    <p>موضع المعامل يحدد ما إذا كان prefix أم postfix.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 118: أنواع المتغيرات التي لا يمكن استخدامها في switch-case</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>جملة <code class="keyword">switch</code> في C/C++ تعمل فقط مع أنواع البيانات الصحيحة (<code class="type">integral types</code>) مثل <code class="type">int</code>, <code class="type">char</code>, <code class="type">enum</code>، وأي أنواع يمكن تحويلها إليها.</p>
                    <p>لا يمكن استخدامها مع أنواع الفاصلة العائمة (<code class="type">floating-point types</code>) مثل <code class="type">float</code> و <code class="type">double</code>.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> float & double.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 119: توقع الـ Output لكود Assignment in If Condition</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>التعبير داخل جملة <code class="keyword">if</code> هو <code dir="ltr">x = 0</code>، وهو عملية إسناد (<code class="type">assignment</code>) وليس مقارنة (<code class="type">comparison</code>).</p>
                    <p>نتيجة عملية الإسناد هي القيمة التي تم إسنادها، وهي 0. في لغة C، القيمة 0 تُعتبر <code class="keyword">false</code>.</p>
                    <p>بما أن الشرط <code class="keyword">false</code>، سيتم تنفيذ كتلة <code class="keyword">else</code>.</p>
                    <div class="output"><strong>الـ Output هو:</strong> Its not zero.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 120: توقع الـ Output لكود Dangling Else</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا مثال على مشكلة "else المعلقة" (<code class="type">dangling else</code>). القاعدة في C/C++ هي أن جملة <code class="keyword">else</code> ترتبط دائمًا بأقرب جملة <code class="keyword">if</code> سابقة لها لا تملك <code class="keyword">else</code> بالفعل.</p>
                    <p>في هذه الحالة، جملة <code class="keyword">printf</code> الثانية التي تلي <code class="keyword">if(a)</code> لا تتبع أي شرط. بدون أقواس معقوفة <code dir="ltr">{}</code>، فإنها تقف بمفردها وتتسبب في فصل جملة <code class="keyword">else</code> عن جملة <code class="keyword">if</code> الخاصة بها، مما يؤدي إلى خطأ في بناء الجملة (<code class="type">syntax error</code>).</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compile time errors during compilation.</div>
                </div>
            </div>

        </div>
    </div>


      <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء السابع: 121-140)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 121: القيمة المرجعة لـ Unary Operator Overloading</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عند إعادة تحميل معامل أحادي (<code class="type">unary operator</code>) وتريد أن يؤثر على الكائن الحالي وأن تتمكن من "سلسلة" العمليات (<code class="type">method chaining</code>)، فإن الطريقة الصحيحة هي إرجاع مرجع للكائن الحالي.</p>
                    <ul>
                        <li>إرجاع <code dir="ltr">this</code>: يُرجع مؤشرًا، وهو ليس الكائن نفسه.</li>
                        <li>إرجاع <code dir="ltr">*this</code>: يقوم بإلغاء الإشارة إلى المؤشر <code dir="ltr">this</code>، مما يُرجع الكائن الحالي نفسه (كمرجع). هذا هو الخيار الصحيح.</li>
                    </ul>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> <code dir="ltr">*this</code>.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 122: تسمية الكلاس الذي يرث من كلاس آخر</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>في الوراثة، توجد تسميات قياسية:</p>
                    <ul>
                        <li><b><code class="type">Base Class</code> (أو <code class="type">Superclass</code>, <code class="type">Parent Class</code>):</b> الكلاس الذي يتم الوراثة منه.</li>
                        <li><b><code class="type">Derived Class</code> (أو <code class="type">Subclass</code>, <code class="type">Child Class</code>):</b> الكلاس الذي يرث.</li>
                    </ul>
                    <p>السؤال يسأل عن الكلاس الذي يرث، والإجابة الصحيحة هي <code class="type">Sub class</code> (أو <code class="type">Derived class</code>).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Sub class.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 123: توقع الـ Output لكود Loop Condition</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>شرط حلقة <code class="keyword">for</code> هو <code dir="ltr">k > -5</code>. القيمة الابتدائية لـ <code dir="ltr">k</code> هي 3.</p>
                    <p>بما أن 3 ليست أكبر من -5، فإن الشرط يكون <code class="keyword">false</code> من البداية. لذلك، لن يتم تنفيذ جسم الحلقة (<code class="keyword">loop body</code>) على الإطلاق.</p>
                    <div class="output"><strong>الـ Output هو:</strong> Nothing.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 124: الحلقة التي تنفذ العملية أولاً ثم تختبر الشرط</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>حلقة <code class="keyword">do-while</code> هي حلقة يتم التحكم فيها عند الخروج (<code class="type">exit-controlled loop</code>). هذا يعني أنها تنفذ جسم الحلقة مرة واحدة على الأقل، ثم تتحقق من الشرط في النهاية لتحديد ما إذا كانت ستستمر في التكرار أم لا.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> do-while loop.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 125: تمرير مصفوفة (Array) إلى دالة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>في C/C++، عند تمرير مصفوفة إلى دالة، لا يتم نسخ المصفوفة بأكملها. بدلاً من ذلك، ما يتم تمريره فعليًا هو عنوان العنصر الأول في المصفوفة (مؤشر).</p>
                    <p>لهذا السبب، فإن التمرير يعمل كتمرير بالمرجع (<code class="type">Pass by reference</code>) أو بشكل أدق، تمرير بالمؤشر (<code class="type">Pass by pointer</code>). أي تعديلات تتم على المصفوفة داخل الدالة ستؤثر على المصفوفة الأصلية.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Call by reference.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 126: تأثير الـ Private Inheritance على الأعضاء العامة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عندما يرث كلاس باستخدام الوراثة الخاصة (<code class="keyword">private inheritance</code>)، فإن جميع الأعضاء العامة (<code class="keyword">public</code>) والمحمية (<code class="keyword">protected</code>) في الكلاس الأساسي تصبح أعضاء خاصة (<code class="keyword">private</code>) في الكلاس المشتق.</p>
                    <p>ونتيجة لذلك، لا يمكن الوصول إلى هذه الأعضاء من الكلاسات التي ترث من الكلاس المشتق (<code class="type">subclasses</code>) أو من خارج الكلاس.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Private.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 127: تعريف الـ Multiple Inheritance</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الوراثة المتعددة (<code class="type">Multiple Inheritance</code>) هي ميزة في C++ تسمح لكلاس جديد بأن يرث من أكثر من كلاس أساسي واحد. هذا يمكّن الكلاس المشتق من تجميع الخصائص والسلوكيات من عدة مصادر مختلفة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Multiple inheritance.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 128: حل مشكلة الـ Ambiguity في الـ Multiple Inheritance</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>يمكن أن يحدث الغموض (<code class="type">Ambiguity</code>) في الوراثة المتعددة إذا كان هناك دالة بنفس الاسم موجودة في أكثر من كلاس أساسي. عندما يحاول الكلاس المشتق استدعاء هذه الدالة، لا يعرف المترجم أي نسخة يجب استخدامها.</p>
                    <p>يتم حل هذه المشكلة باستخدام معامل تحديد النطاق (<code dir="ltr">::</code>) لتحديد الكلاس الأساسي المقصود بشكل صريح، على سبيل المثال: <code dir="ltr">BaseClassName::method();</code>.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 129: تعريف الـ Function Overriding</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>إعادة تعريف الدالة (<code class="type">Function Overriding</code>) تحدث عندما يقوم كلاس مشتق بتعريف دالة لها نفس الاسم، ونفس نوع الإرجاع، ونفس الوسائط مثل دالة في كلاسها الأساسي. هذا يسمح للكلاس المشتق بتوفير تطبيق مخصص لدالة موروثة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> function overriding.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 130: متطلبات الـ Overriding Method</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لكي تقوم دالة في الكلاس المشتق بإعادة تعريف دالة في الكلاس الأساسي، يجب أن يكون لها:</p>
                    <ul>
                        <li>نفس اسم الدالة.</li>
                        <li>نفس قائمة الوسائط (الأنواع والترتيب).</li>
                        <li>نفس نوع الإرجاع (أو نوع إرجاع متوافق Covariant).</li>
                    </ul>
                    <p>هذا يُعرف بـ "نفس التوقيع" (<code class="type">same signature</code>).</p>
                    <div class="answer true"><strong>الإجابة الصحيحة هي:</strong> same return type, same function name, and same parameters.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 131: الوصول لـ Overridden Function في الـ Base Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>للوصول إلى نسخة الدالة الموجودة في الكلاس الأساسي (التي تم إعادة تعريفها في الكلاس المشتق) من داخل الكلاس المشتق، نستخدم معامل تحديد النطاق (<code dir="ltr">::</code>).</p>
                    <p>الصيغة هي <code dir="ltr">BaseClassName::functionName();</code>.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> :: the scope resolution operator.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 132: تمكين الـ Override عبر Pointer</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لكي يعمل تعدد الأشكال في وقت التشغيل (runtime polymorphism) عند استخدام مؤشر من نوع الكلاس الأساسي يشير إلى كائن من الكلاس المشتق، يجب أن تكون الدالة التي تريد إعادة تعريفها مُعلنة كـ <code class="keyword">virtual</code> في الكلاس الأساسي.</p>
                    <p>إعلان الدالة كـ <code class="keyword">virtual</code> يمكّن آلية الإرسال الديناميكي (<code class="type">dynamic dispatch</code>).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> virtual functions in the Base class.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 133: تعريف الـ Pure Virtual Function</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدالة الافتراضية النقية (<code class="type">Pure Virtual Function</code>) هي دالة افتراضية ليس لها تطبيق (<code class="keyword">implementation</code>) في الكلاس الأساسي. يتم الإعلان عنها عن طريق إسناد 0 لها، مثل <code dir="ltr">virtual void draw() = 0;</code>.</p>
                    <p>تعمل كعقد (<code class="type">contract</code>) يجبر أي كلاس مشتق ملموس (<code class="type">concrete</code>) على توفير تطبيق لهذه الدالة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> A pure virtual function.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 134: تعريف الـ Abstract Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلاس المجرد (<code class="type">Abstract Class</code>) هو كلاس مصمم ليكون كلاسًا أساسيًا. لا يمكن إنشاء كائنات منه مباشرة. يجب أن يحتوي على دالة افتراضية نقية واحدة على الأقل. يعمل كواجهة (<code class="type">interface</code>) مشتركة للكلاسات المشتقة منه.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Abstract class.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 135: متى يصبح الـ Derived Class ملموسًا (Concrete)</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لكي يصبح كلاس مشتق من كلاس مجرد كلاسًا ملموسًا (<code class="type">concrete</code>) (أي يمكن إنشاء كائنات منه)، يجب عليه توفير تطبيقات (<code class="keyword">implementations</code>) لجميع الدوال الافتراضية النقية (<code class="keyword">pure virtual functions</code>) التي ورثها من الكلاس الأساسي.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> you override each pure virtual function in the derived class.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 136: ميزة إعادة استخدام الكود (Code Reuse) في OOP</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>إعادة استخدام الكود هي إحدى المزايا الرئيسية للبرمجة كائنية التوجه. يتم تحقيقها بشكل أساسي من خلال الوراثة (<code class="keyword">Inheritance</code>)، حيث يسمح لكلاس جديد (مشتق) بوراثة الخصائص والسلوكيات من كلاس موجود (أساسي)، مما يمكنك من إعادة استخدام الكود الموجود والبناء عليه بدلاً من كتابته من جديد.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Inheritance.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 137: تعريف علاقة IS-A</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>علاقة "IS-A" (هو نوع من) هي السمة المميزة للوراثة (<code class="type">Inheritance</code>). تعني أن الكلاس المشتق هو نسخة أكثر تخصصًا من الكلاس الأساسي. على سبيل المثال، "السيارة هي نوع من المركبات" (<code dir="ltr">Car IS-A Vehicle</code>).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Inheritance.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 138: علاقة Doctor و Patient</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العلاقة بين الطبيب والمريض هي مثال على الارتباط (<code class="type">Association</code>). يمكن أن يكون للطبيب العديد من المرضى، ويمكن للمريض أن يزور العديد من الأطباء. الكائنان (الطبيب والمريض) لهما دورات حياة مستقلة (وجود أحدهما لا يعتمد على وجود الآخر).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Association.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 139: القيمة المرجعة لدالة strcmp()</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدالة <code dir="ltr">strcmp()</code> تقارن بين سلسلتين نصيتين وتُرجع قيمة من نوع <code class="type">int</code>:</p>
                    <ul>
                        <li><b>0:</b> إذا كانت السلسلتان متطابقتين.</li>
                        <li><b>قيمة سالبة:</b> إذا كانت السلسلة الأولى تأتي أبجديًا قبل الثانية.</li>
                        <li><b>قيمة موجبة:</b> إذا كانت السلسلة الأولى تأتي أبجديًا بعد الثانية.</li>
                    </ul>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> int.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 140: توقع الـ Output لكود Infinite Recursion</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدالة <code dir="ltr">m()</code> تستدعي نفسها بشكل متكرر دون وجود حالة توقف (<code class="type">terminating condition</code>). هذا يؤدي إلى استدعاء ذاتي لانهائي (<code class="type">infinite recursion</code>).</p>
                    <p>كل استدعاء للدالة يستهلك مساحة على مكدس الاستدعاء (<code class="type">call stack</code>). في النهاية، سيمتلئ المكدس وسيؤدي إلى خطأ فادح يسمى فيضان المكدس (<code class="type">stack overflow</code>)، مما يتسبب في تعطل البرنامج.</p>
                    <div class="output"><strong>الـ Output هو:</strong> طباعة "hi" بشكل متكرر حتى يحدث stack overflow.</div>
                </div>
            </div>
            
        </div>
    </div>


     <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء الثامن: 141-160)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 141: توقع الـ Output لكود Void Function Return Value</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدالة <code dir="ltr">foo</code> مُعلنة على أنها تُرجع <code class="keyword">void</code>، مما يعني أنها لا يجب أن تُرجع أي قيمة.</p>
                    <p>الجملة <code dir="ltr">return 1;</code> داخل الدالة تحاول إرجاع قيمة من نوع <code class="type">int</code>، وهذا يتعارض مع تعريف الدالة. سيؤدي هذا إلى خطأ في الترجمة (<code class="type">compile-time error</code>).</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compile time error.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 142: توقع الـ Output لكود Passing Array to Function</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عند تمرير مصفوفة إلى دالة، يتم تمرير مؤشر إلى عنصرها الأول. أي تعديل على المؤشر داخل الدالة هو تعديل محلي ولا يؤثر على المصفوفة الأصلية.</p>
                    <ol>
                        <li>في دالة <code dir="ltr">foo</code>، المؤشر المحلي <code dir="ltr">p</code> يشير أولاً إلى <code dir="ltr">ary</code>.</li>
                        <li>السطر <code dir="ltr">p = &i;</code> يجعل <code dir="ltr">p</code> يشير إلى المتغير المحلي <code dir="ltr">i</code>. هذا لا يغير <code dir="ltr">ary</code> الأصلية.</li>
                        <li>الطباعة داخل <code dir="ltr">foo</code> تطبع قيمة <code dir="ltr">i</code> وهي 10.</li>
                        <li>عند العودة إلى <code dir="ltr">main</code>، <code dir="ltr">ary[0]</code> لم تتغير. الطباعة تطبع قيمتها الأصلية وهي 1.</li>
                    </ol>
                    <div class="output"><strong>الـ Output هو:</strong> 10 1.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 143: تعريف الـ Array في C</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>المصفوفة (<code class="keyword">Array</code>) في لغة C هي مجموعة من العناصر من نفس نوع البيانات، يتم تخزينها في مواقع ذاكرة متجاورة. يمكن الوصول إلى عناصرها باستخدام فهرس (<code class="keyword">index</code>).</p>
                    <p>كل العبارات المذكورة في المصدر تصف جوانب صحيحة من المصفوفات في C.</p>
                    <div class="answer true"><strong>الإجابة الصحيحة هي:</strong> All of the mentioned.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 144: حل مشكلة أبراج هانوي (Tower of Hanoi)</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>حل مشكلة أبراج هانوي هو مثال كلاسيكي على الاستدعاء الذاتي (<code class="type">Recursion</code>). الخطوات هي:</p>
                    <ol>
                        <li>نقل <code dir="ltr">n-1</code> قرصًا من المصدر (<code dir="ltr">a</code>) إلى الوتد المساعد (<code dir="ltr">b</code>).</li>
                        <li>نقل أكبر قرص (رقم <code dir="ltr">n</code>) من المصدر (<code dir="ltr">a</code>) إلى الوجهة (<code dir="ltr">c</code>).</li>
                        <li>نقل <code dir="ltr">n-1</code> قرصًا من الوتد المساعد (<code dir="ltr">b</code>) إلى الوجهة (<code dir="ltr">c</code>).</li>
                    </ol>
                    <p>السؤال يطلب إكمال الخطوة الأولى، وهي <code dir="ltr">move(n-1, a, c, b)</code> (في المصدر تم استخدام <code dir="ltr">a,b,c</code> بشكل مختلف). بناءً على المتغيرات في المصدر، الجزء الناقص هو استدعاء لنقل الأقراص من <code dir="ltr">a</code> إلى <code dir="ltr">b</code> باستخدام <code dir="ltr">c</code> كمساعد.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> <code dir="ltr">move(n-1, a, c, b);</code> (مع مراعاة أن ترتيب الوسائط قد يختلف).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 145: أفضل خوارزمية ترتيب للبيانات شبه المرتبة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>للبيانات التي تكون شبه مرتبة بالفعل، يعتبر الترتيب الفقاعي (<code class="type">Bubble Sort</code>) (بنسخته المحسنة) خيارًا جيدًا جدًا. يمكن للنسخة المحسنة اكتشاف أن القائمة مرتبة والتوقف مبكرًا، مما يجعل تعقيده الزمني في أفضل الحالات <code dir="ltr">O(n)</code>.</p>
                    <p>في المقابل، الترتيب بالاختيار (<code class="type">Selection Sort</code>) دائمًا ما يقوم بنفس عدد المقارنات والتبديلات بغض النظر عن حالة الترتيب الأولية، مما يجعل تعقيده دائمًا <code dir="ltr">O(n^2)</code>.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Bubble sort.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 146: صلاحية الكود الذي يستخدم كلمة 'friend'</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <ul>
                        <li><b>في C++:</b> <code class="keyword">friend</code> هي كلمة مفتاحية محجوزة. لا يمكن استخدامها كاسم لمتغير. هذا سيؤدي إلى خطأ في الترجمة.</li>
                        <li><b>في C:</b> لغة C لا تحتوي على مفهوم الكلاسات أو الكلمة المفتاحية <code class="keyword">friend</code>. لذلك، <code dir="ltr">friend</code> هو مجرد اسم صالح لمتغير.</li>
                    </ul>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> C valid only.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 147: أكثر من Constructor في نفس الكلاس</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>يمكن أن يحتوي الكلاس على أكثر من <code class="keyword">constructor</code>. هذه الميزة تُعرف بإعادة تحميل المُنشئ (<code class="type">Constructor Overloading</code>).</p>
                    <p>وظيفة الـ <code class="keyword">destructor</code> الأساسية هي تحرير الموارد (<code class="type">clean up resources</code>) التي قد يكون الكائن قد حجزها (مثل الذاكرة الديناميكية أو الملفات)، وليس إلغاء تخصيص ذاكرة الكائن نفسه.</p>
                    <div class="answer false"><strong>العبارة "أكتر من constructor" صحيحة. العبارة عن وظيفة الـ destructor خاطئة.</strong> (المستند يدمج الفكرتين ويصنفها كـ False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 149: هل يجب أن تحتوي الـ Abstract Class على Virtual Functions؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلاس المجرد (<code class="type">Abstract Class</code>) هو كلاس يحتوي على دالة افتراضية نقية (<code class="keyword">pure virtual function</code>) واحدة على الأقل. أي دالة افتراضية نقية هي بالضرورة دالة افتراضية (<code class="keyword">virtual function</code>).</p>
                    <p>لذلك، يجب أن يحتوي الكلاس المجرد على دوال افتراضية. يمكنه أيضًا أن يحتوي على دوال افتراضية عادية ودوال غير افتراضية.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 151: إعلان Constructor كـ void</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الـ <code class="keyword">Constructors</code> هي دوال خاصة ليس لها نوع إرجاع، ولا حتى <code class="keyword">void</code>. الإعلان الصريح عن <code class="keyword">constructor</code> مع نوع إرجاع <code class="keyword">void</code> (أو أي نوع آخر) يعتبر خطأ في بناء الجملة (<code class="type">syntax error</code>).</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 152: علاقات الـ Association و Aggregation</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة تخلط بين المفاهيم. <code class="type">Association</code> و <code class="type">Aggregation</code> هما علاقات "has-a" أو "uses-a" بين الكلاسات، وهي مختلفة عن علاقة الوراثة "is-a" (<code class="type">Inheritance</code>).</p>
                    <p>تعريف هذه العلاقات لا يرتبط بقائمة التهيئة (<code class="keyword">initializer list</code>) بشكل مباشر. يمكن تنفيذها باستخدام أعضاء البيانات التي هي كائنات أو مؤشرات لكلاسات أخرى.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 154: عمل Overload لـ Scope Operator (::)</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لا يمكن إعادة تحميل معامل تحديد النطاق (<code dir="ltr">::</code>). إنه أحد المعاملات القليلة في C++ التي لا يمكن للمبرمج إعادة تعريف سلوكها.</p>
                    <div class="answer true"><strong>العبارة "مش بتسمح بعمل overload":</strong> صحيحة (True).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 156: تصميم Classes لحساب حجم الأشكال</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال تصميمي يتطلب استخدام مفاهيم OOP.</p>
                    <ul>
                        <li>كلاس أساسي مجرد <code class="keyword">Shape</code> (أو <code class="keyword">ThreeDShape</code>) مع دالة افتراضية نقية مثل <code dir="ltr">virtual double calc_volume() = 0;</code>.</li>
                        <li>كلاسات مشتقة ملموسة مثل <code class="keyword">Cylinder</code>, <code class="keyword">Cube</code>, <code class="keyword">Box</code>، كل منها يرث من <code class="keyword">Shape</code> ويوفر تطبيقًا خاصًا لدالة <code dir="ltr">calc_volume()</code>.</li>
                    </ul>
                    <div class="answer"><strong>الحل:</strong> View Solution (يشير إلى أن الحل يكمن في تطبيق هذا التصميم).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 157: وصول دالة main لعضو public</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "لا يمكنك الوصول إلى عضو عام مباشرة باسمه في دالة main" هي <b>خاطئة</b>.</p>
                    <p>إذا كان هناك عضو عام (<code class="keyword">public member</code>) في كلاس، يمكنك الوصول إليه مباشرة من أي مكان خارج الكلاس (بما في ذلك <code class="keyword">main</code>) باستخدام كائن من هذا الكلاس والمعامل <code dir="ltr">.</code> أو <code dir="ltr">-></code>.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 158: وصول Friend Function للأعضاء</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عندما يتم إعلان دالة كـ <code class="keyword">friend</code> لكلاس، فإنها تحصل على وصول خاص وكامل إلى جميع أعضاء هذا الكلاس، بما في ذلك الأعضاء الخاصة (<code class="keyword">private</code>) والمحمية (<code class="keyword">protected</code>).</p>
                    <div class="answer false"><strong>العبارة "بتمنحها وصول لكل non-public members":</strong> صحيحة، مما يجعل العبارة في المستند خاطئة (False).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 160: الوصول لـ Static Variable</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>للوصول إلى متغير ثابت (<code class="keyword">static variable</code>) من خارج الكلاس، يجب استخدام اسم الكلاس متبوعًا بمعامل تحديد النطاق (<code dir="ltr">::</code>) ثم اسم المتغير.</p>
                    <p>الصيغة الصحيحة هي: <code dir="ltr">ClassName::static_variable</code>.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

        </div>
    </div>

       <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء التاسع: 161-180)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 161: المؤشر 'this'</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>المؤشر <code class="keyword">this</code> هو مؤشر ضمني (<code class="type">implicit pointer</code>) يتم تمريره إلى كل دالة عضو غير ثابتة. إنه يشير إلى عنوان الذاكرة الخاص بالكائن الذي استدعى الدالة، مما يسمح للدالة بالوصول إلى أعضاء هذا الكائن المحدد.</p>
                    <p>العبارة 267 في المصدر التي تصف الـ constructor هي خطأ في ترقيم السؤال.</p>
                    <div class="answer false"><strong>العبارة "مينفعش يرجع أي return type":</strong> صحيحة بالنسبة للـ constructor، لكن السؤال عن <code class="keyword">this</code>. العبارة الأساسية عن <code class="keyword">this</code> صحيحة.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 162: توقع الـ Output لكود Private Method Access</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا السؤال مكرر (رقم 26). في <code class="keyword">class C</code>، الدالة <code dir="ltr">seti()</code> تكون <code class="keyword">private</code> افتراضيًا.</p>
                    <p>محاولة استدعاء هذه الدالة الخاصة من خارج الكلاس (في <code class="keyword">main</code>) ستؤدي إلى خطأ في الترجمة (<code class="type">compilation error</code>).</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> The compiler generates an error because the method "seti" is not accessible.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 163: توقع الـ Output لكود Undefined Symbol</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا السؤال مكرر (رقم 27). في لغة C++، يجب تعريف المتغيرات قبل استخدامها.</p>
                    <p>الكود يستخدم المتغير <code dir="ltr">i</code> في حلقة <code class="keyword">for</code> دون أن يتم تعريفه مسبقًا. سيؤدي هذا إلى خطأ في الترجمة لأن المترجم لا يتعرف على الرمز <code dir="ltr">i</code>.</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> An error occurs because the var i is not visible in the for loop (undefined symbol i).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 164: تعريف Encapsulation</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "التغليف يعني توسيع كلاس" هي <b>خاطئة</b>. هذا هو وصف الوراثة (<code class="type">Inheritance</code>).</p>
                    <p>التغليف (<code class="type">Encapsulation</code>) هو مبدأ تجميع البيانات (<code class="keyword">data</code>) والدوال (<code class="keyword">methods</code>) التي تعمل عليها في وحدة واحدة (كلاس)، وتقييد الوصول المباشر إلى مكوناته الداخلية.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 165: تعديل Static Member Variable بعد تخصيص قيمة لها</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "إذا تم تخصيص قيمة لمتغير ثابت، لا يمكن تغييرها" هي <b>خاطئة</b>. هذا هو وصف المتغيرات الثابتة من نوع <code class="keyword">const</code>.</p>
                    <p>المتغير العضو الثابت (<code class="keyword">static member variable</code>) هو متغير مشترك بين جميع كائنات الكلاس. يمكن تعديل قيمته في أي وقت خلال تنفيذ البرنامج ما لم يتم إعلانه كـ <code class="keyword">const</code>.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 166: Function Overloading وتغيير عدد الـ Parameters</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "يجب تغيير عدد الوسائط عند إعادة تحميل دالة" هي <b>خاطئة</b>.</p>
                    <p>لإعادة تحميل دالة، يجب أن يكون "توقيعها" (<code class="type">signature</code>) فريدًا. التوقيع يتكون من اسم الدالة وقائمة الوسائط (العدد، الأنواع، الترتيب). يمكنك إعادة تحميل دالة عن طريق تغيير عدد الوسائط، أو عن طريق تغيير أنواعها حتى لو كان العدد هو نفسه.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 167: وصول الـ Derived Class لأعضاء الـ Base Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلاس المشتق (<code class="keyword">Derived Class</code>) يرث الأعضاء العامة (<code class="keyword">public</code>) والمحمية (<code class="keyword">protected</code>) من الكلاس الأساسي ويمكنه الوصول إليها مباشرة. الأعضاء الخاصة (<code class="keyword">private</code>) في الكلاس الأساسي لا يمكن الوصول إليها مباشرة من الكلاس المشتق.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> The protected and public members of the base class.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 168: الفرق بين Multiple Inheritance و Multi-Level Inheritance</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <ul>
                        <li><b><code class="type">Multi-Level Inheritance</code> (وراثة متعددة المستويات):</b> تشكل سلسلة وراثية. كلاس <code dir="ltr">C</code> يرث من <code dir="ltr">B</code>، وكلاس <code dir="ltr">B</code> يرث من <code dir="ltr">A</code> (<code dir="ltr">A -> B -> C</code>).</li>
                        <li><b><code class="type">Multiple Inheritance</code> (وراثة متعددة):</b> كلاس واحد يرث من أكثر من كلاس أساسي مباشرة. كلاس <code dir="ltr">C</code> يرث من <code dir="ltr">A</code> و <code dir="ltr">B</code> معًا.</li>
                    </ul>
                    <p>السؤال يصف الوراثة متعددة المستويات.</p>
                    <div class="answer"><strong>الوصف يخص:</strong> Multi-Level Inheritance.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 169: الميزات الأساسية لـ OOP</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الميزات الأساسية للبرمجة كائنية التوجه (OOP) هي:</p>
                    <ul>
                        <li><b>Encapsulation (التغليف)</b></li>
                        <li><b>Inheritance (الوراثة)</b></li>
                        <li><b>Polymorphism (تعدد الأشكال)</b></li>
                        <li><b>Abstraction (التجريد)</b></li>
                    </ul>
                    <p>الوصف في المستند لـ <code class="type">Inheritance</code> غير دقيق ويشبه وصف <code class="type">Abstraction</code>.</p>
                    <div class="answer"><strong>الإجابة:</strong> Choose Any To See The Written Answer (يشير إلى أن الخيارات المتاحة قد تكون مربكة أو غير دقيقة).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 170: معنى علاقة Aggregation وتأثيرها على Constructors</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>التجميع (<code class="type">Aggregation</code>) هو نوع خاص من الارتباط (<code class="type">Association</code>) يمثل علاقة "has-a" أو "part-of" حيث يمكن للجزء أن يوجد بشكل مستقل عن الكل. على سبيل المثال، القسم والطلاب؛ إذا تم حل القسم، لا يختفي الطلاب.</p>
                    <p>عند إنشاء الكائن "الكل"، يجب أن يتم إنشاء الكائنات "الأجزاء" قبله أو في نفس الوقت. لذلك، يتم استدعاء مُنشئات الأجزاء قبل مُنشئ الكل.</p>
                    <div class="answer"><strong>التأثير:</strong> مُنشئات الكائنات المجمعة تُستدعى قبل مُنشئ الكائن الحاوي.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 171: خصائص الـ Constructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 104). خصائص الـ <code class="keyword">constructor</code> هي:</p>
                    <ul>
                        <li>هو دالة خاصة (<code class="type">special method</code>) يتم استدعاؤها تلقائيًا.</li>
                        <li>له نفس اسم الكلاس.</li>
                        <li>ليس له نوع إرجاع.</li>
                    </ul>
                    <div class="answer"><strong>الإجابة:</strong> Choose Any To See The Written Answer.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 172: تصميم Classes لـ Airlines Company Information System</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال تصميمي يتطلب استخدام الوراثة. التصميم الجيد يتضمن:</p>
                    <ul>
                        <li>كلاس أساسي <code class="keyword">Employee</code> يحتوي على خصائص مشتركة مثل <code dir="ltr">ID</code> و <code dir="ltr">Name</code>.</li>
                        <li>كلاسات مشتقة مثل <code class="keyword">Captain</code>, <code class="keyword">CoPilot</code>, <code class="keyword">Host</code> ترث من <code class="keyword">Employee</code> وتضيف خصائصها الفريدة.</li>
                    </ul>
                    <p>العبارة في المستند التي تقول أن هذا ليس <code class="type">multilevel inheritance</code> صحيحة (هذه وراثة هرمية)، لكن تصنيف الإجابة كـ <code class="keyword">False</code> قد يكون مربكًا.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 174: هل this Pointer هو array of pointers؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "المؤشر this هو مصفوفة من المؤشرات" هي <b>خاطئة</b>.</p>
                    <p>المؤشر <code class="keyword">this</code> هو مؤشر واحد (<code class="type">single pointer</code>) يتم تمريره ضمنيًا إلى الدوال الأعضاء غير الثابتة. وظيفته هي تخزين عنوان الذاكرة الخاص بالكائن الحالي الذي استدعى الدالة.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة. (المستند يذكر "غلط عن Object Member Function. الكود ده هو نفسه السؤال 61").</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 176: وصول Friend Function لأعضاء الكلاس</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 158). الدالة الصديقة (<code class="keyword">Friend Function</code>) لكلاس <code dir="ltr">A</code> يمكنها الوصول إلى جميع أعضاء <code dir="ltr">A</code>، بما في ذلك <code class="keyword">private</code> و <code class="keyword">protected</code>.</p>
                    <p>العبارة في المستند تقول أنها تصل فقط إلى الأعضاء الخاصة وهذا خطأ.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 177: توقع الـ Output لكود Copy Constructor and Increment</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكود المقدم يحتوي على عدة خيارات لدوال <code dir="ltr">myFunc</code>. العبارة تقول أن جميع الخيارات غير صالحة لإعادة التحميل (<code class="keyword">overloading</code>) باستثناء واحد.</p>
                    <ul>
                        <li><b>B. <code dir="ltr">int myFunc(int x)</code>:</b> غير صالح لأنه يختلف فقط في نوع الإرجاع عن الأصل.</li>
                        <li><b>D. <code dir="ltr">float myFunc(int x, int y)</code>:</b> صالح لأنه يختلف في عدد ونوع الوسائط.</li>
                        <li><b>C. <code dir="ltr">void myFunc(char c1, char c2)</code>:</b> صالح لأنه يختلف في عدد ونوع الوسائط.</li>
                    </ul>
                    <div class="answer false"><strong>العبارة "كلها غلط":</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 179: وصول الكلاس المشتق لأعضاء الكلاس الأساسي</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر. الكلاس المشتق يمكنه الوصول إلى الأعضاء العامة (<code class="keyword">public</code>) والمحمية (<code class="keyword">protected</code>) من الكلاس الأساسي.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> a) The protected and public members of the base class.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 180: Function Overloading كشكل من أشكال Polymorphism</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>إعادة تحميل الدوال (<code class="keyword">Function Overloading</code>) هي بالفعل شكل من أشكال تعدد الأشكال (<code class="type">Polymorphism</code>). على وجه التحديد، هي مثال على تعدد الأشكال في وقت الترجمة (<code class="type">compile-time polymorphism</code>) أو الربط الثابت (<code class="type">static binding</code>).</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

        </div>
    </div>


       <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء العاشر: 181-200)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 181: تعريف الـ Embedded (Aggregated) Object</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 45). الكائن المضمن (<code class="type">Embedded Object</code>) هو كائن يتم تضمينه كعضو بيانات (<code class="keyword">data member</code>) داخل كلاس آخر. هذا يمثل علاقة "has-a" وهو أساس مفاهيم مثل <code class="type">Composition</code> و <code class="type">Aggregation</code>.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> An object that is included by another object.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 182: متى يتم استدعاء الـ Copy Constructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>مُنشئ النسخ (<code class="keyword">Copy Constructor</code>) هو المسؤول عن إنشاء نسخة كاملة ومستقلة من كائن موجود. يتم استدعاؤه تلقائيًا عند تهيئة كائن جديد باستخدام كائن آخر من نفس النوع.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True). لكن المستند يضيف ملاحظة "لكن ده بيسمى hiding مش overriding" وهي غير ذات صلة بالسؤال الأساسي.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 184: هل يمكن لأي كائن استقبال نفس الرسائل؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>"إرسال رسالة" إلى كائن هو مصطلح في OOP يعني "استدعاء دالة عضو". يمكن للكائن أن يستقبل الرسائل (يستدعي الدوال) المعرفة في كلاسه أو في أي من كلاساته الأساسية. لا يمكنه استقبال رسائل (استدعاء دوال) من كلاسات لا علاقة لها به.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True) ضمن سياق أن الكائن يمكنه استقبال الرسائل المخصصة له.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 186: المصطلح الصحيح لإضافة وظائف لـ Operator</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>المصطلح الصحيح لتقديم تعريف جديد أو سلوك مخصص لمعامل (<code class="keyword">operator</code>) هو <code class="type">Operator Overloading</code> (إعادة تحميل المعامل).</p>
                    <p><code class="type">Operator Overriding</code> ليس مصطلحًا قياسيًا في C++.</p>
                    <div class="answer"><strong>المصطلح الصحيح هو:</strong> Operator Overloading.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 188: وصول الأعضاء المحمية في الوراثة الخاصة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>حتى في الوراثة الخاصة (<code class="keyword">Private Inheritance</code>)، يظل الكلاس المشتق قادرًا على الوصول إلى الأعضاء العامة (<code class="keyword">public</code>) والمحمية (<code class="keyword">protected</code>) من الكلاس الأساسي المباشر له. ما يتغير هو أن هذه الأعضاء تصبح خاصة (<code class="keyword">private</code>) داخل الكلاس المشتق.</p>
                    <p>نمط الوراثة يؤثر على كيفية وصول العالم الخارجي والكلاسات المشتقة لاحقًا إلى الأعضاء الموروثة، وليس على وصول الكلاس المشتق نفسه إليها.</p>
                    <div class="answer false"><strong>العبارة في المستند:</strong> خاطئة (False).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 190: أي دالة يمكنها التعامل مع Instance Variables</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>متغيرات النسخة (<code class="type">Instance Variables</code>)، وهي الأعضاء غير الثابتة، مرتبطة بكائن معين. الدوال التي يمكنها التعامل معها هي الدوال العضو غير الثابتة (<code class="type">non-static instance methods</code>) لأنها تحصل على مؤشر <code class="keyword">this</code> الذي يشير إلى الكائن الحالي.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 191: وصول الأعضاء المحمية من نفس الملف</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "يمكن الوصول للأعضاء المحمية إذا كان الكلاس في نفس الملف" هي <b>خاطئة</b>.</p>
                    <p>قواعد الوصول (<code class="keyword">public</code>, <code class="keyword">protected</code>, <code class="keyword">private</code>) لا علاقة لها بتنظيم الكود في ملفات. العضو المحمي (<code class="keyword">protected</code>) يمكن الوصول إليه فقط من داخل الكلاس نفسه أو من الكلاسات المشتقة منه، بغض النظر عن مكان تعريفها في الملفات.</p>
                    <p>استخدام <code class="type">getters</code> و <code class="type">setters</code> هو نمط لتوفير وصول متحكم فيه للبيانات الخاصة.</p>
                    <div class="answer true"><strong>العبارة في المستند:</strong> صحيحة (True)، ولكن التبرير المقدم في النص الأصلي غير دقيق.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 193: هل كل كائنات نفس الكلاس لها علاقة is-a؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة <b>خاطئة</b>. علاقة "is-a" تصف الوراثة بين الكلاسات (الكلاس المشتق "هو نوع من" الكلاس الأساسي).</p>
                    <p>العلاقة بين الكائنات من نفس الكلاس ليست "is-a". العلاقة بين كائنات مختلفة (حتى من كلاسات مختلفة) قد تكون <code class="type">Association</code> (مثل "has-a" أو "uses-a")، والتي تصف كيف تتفاعل الكائنات مع بعضها البعض.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 195: تعريف الـ Overriding</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "Overriding يعني إعادة تنفيذ دالة موروثة بنفس الاسم والوسائط" هي <b>صحيحة</b>. هذا هو التعريف الدقيق لإعادة تعريف الدالة.</p>
                    <p>الجزء الآخر من النص الأصلي عن لغة C غير مرتبط بشكل مباشر بتعريف الـ Overriding.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 197: العلاقة بين Class Monkey و Class Animal</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العلاقة "القرد هو حيوان" (<code dir="ltr">Monkey "is an" Animal</code>) هي مثال كلاسيكي على الوراثة (<code class="type">Inheritance</code>). كلاس <code class="keyword">Monkey</code> سيرث من كلاس <code class="keyword">Animal</code>.</p>
                    <p>العبارة التي تقول أنها علاقة <code class="type">association</code> هي <b>خاطئة</b>.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 199: العبارة الخاطئة عن Multilevel inheritance</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "Multilevel inheritance not allowed in C++" هي <b>خاطئة</b>.</p>
                    <p>لغة C++ تدعم الوراثة متعددة المستويات (<code class="type">Multilevel Inheritance</code>) بشكل كامل، حيث يمكن لكلاس أن يرث من كلاس مشتق بالفعل، مكونًا سلسلة وراثية.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 200: علاقة Association و Composition</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "Association هو نوع خاص من Composition" هي <b>خاطئة</b>.</p>
                    <p>العكس هو الصحيح. <code class="type">Composition</code> (التكوين) هو نوع خاص وأكثر تقييدًا من <code class="type">Association</code> (الارتباط). <code class="type">Association</code> هو المصطلح العام الذي يصف أي علاقة هيكلية بين الكلاسات.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

        </div>
    </div>


      <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء الحادي عشر: 201-220)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 201: تعريف Encapsulation</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "Encapsulation معناها أن كائن من كلاس بداخله كائن من كلاس آخر" هي <b>خاطئة</b>. هذا هو وصف الـ <code class="type">Composition</code>.</p>
                    <p>التغليف (<code class="type">Encapsulation</code>) هو مبدأ تجميع البيانات (<code class="keyword">data</code>) والدوال (<code class="keyword">methods</code>) في وحدة واحدة (كلاس) مع التحكم في الوصول إلى البيانات الداخلية (<code class="type">Data Hiding</code>).</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 202: الأعضاء التي يتم وراثتها في Derived Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عندما يرث كلاس، فإنه يرث جميع الأعضاء من الكلاس الأساسي، بما في ذلك الأعضاء الخاصة (<code class="keyword">private</code>). ومع ذلك، لا يمكن للكلاس المشتق الوصول مباشرة إلى الأعضاء الخاصة للكلاس الأساسي.</p>
                    <p>تكون هذه الأعضاء الخاصة جزءًا من ذاكرة الكائن المشتق، ولكن لا يمكن الوصول إليها إلا من خلال الدوال العامة أو المحمية للكلاس الأساسي.</p>
                    <div class="answer false"><strong>العبارة "يقدر يوصل مباشرة بس للـ public و protected":</strong> صحيحة، مما يجعل العبارة العامة في المستند خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 203: تعديل الـ Static Member Variables</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "لازم تتعدل بس عن طريق static member functions" هي <b>خاطئة</b>.</p>
                    <p>المتغيرات العضوية الثابتة (<code class="keyword">static member variables</code>) يمكن تعديلها من خلال:</p>
                    <ul>
                        <li>الدوال الثابتة (<code class="keyword">static methods</code>).</li>
                        <li>الدوال غير الثابتة (<code class="keyword">non-static / instance methods</code>).</li>
                    </ul>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 204: وصول الـ Friend Function لأعضاء الكلاس</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدالة الصديقة (<code class="keyword">Friend Function</code>) لكلاس <code dir="ltr">A</code> يمكنها الوصول إلى جميع الأعضاء غير العامة (<code class="type">non-public</code>) في <code dir="ltr">A</code>، وهذا يشمل الأعضاء الخاصة (<code class="keyword">private</code>) والمحمية (<code class="keyword">protected</code>) على حد سواء.</p>
                    <p>العبارة في السؤال "فقط الـ private" تجعلها <b>خاطئة</b>.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 205: علاقة Composition و Inheritance</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "Composition هو نوع خاص من Inheritance" هي <b>خاطئة</b>.</p>
                    <p>هما مفهومان مختلفان تمامًا. <code class="type">Composition</code> يمثل علاقة "has-a" (يحتوي على)، بينما <code class="type">Inheritance</code> يمثل علاقة "is-a" (هو نوع من). لا يوجد علاقة مباشرة بينهما من حيث كون أحدهما نوعًا خاصًا من الآخر.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 206: تعريف الـ this Pointer</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "this pointer هو array of pointers" هي <b>خاطئة</b>.</p>
                    <p>المؤشر <code class="keyword">this</code> هو مؤشر واحد (<code class="type">single pointer</code>)، وليس مصفوفة. يتم تمريره كوسيط ضمني إلى كل دالة عضو غير ثابتة ويحمل عنوان الذاكرة للكائن الحالي.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 207: Function Overloading وتغيير عدد الـ Parameters</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "يجب تغيير عدد الوسائط لعمل overload" هي <b>خاطئة</b>.</p>
                    <p>لعمل <code class="keyword">overload</code>، يجب أن يكون توقيع الدالة (<code class="type">signature</code>) فريدًا. يمكن تحقيق ذلك بتغيير عدد الوسائط، أو بتغيير أنواعها، أو بترتيبها. تغيير العدد هو أحد الطرق، وليس الطريقة الوحيدة.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 208: الأعضاء التي يتم وراثتها في Subclass</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلاس الفرعي (<code class="type">Subclass</code>) يرث الأعضاء العامة (<code class="keyword">public</code>) والمحمية (<code class="keyword">protected</code>) من الكلاس الأساسي. هو لا يرث الأعضاء الخاصة (<code class="keyword">private</code>) بمعنى أنه لا يستطيع الوصول إليها.</p>
                    <p>العبارة في المستند تقول أن <code class="keyword">protected</code> لا يتم وراثتها، وهذا <b>خطأ</b>.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 209: Operator Overloading لـ [ ]</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة تقول أنه لا يمكن عمل <code class="keyword">overload</code> لمعامل الأقواس المربعة <code dir="ltr">[]</code>. هذه العبارة <b>خاطئة</b>.</p>
                    <p>يمكن إعادة تحميل معامل الوصول إلى الفهرس (<code class="type">subscript operator</code>) <code dir="ltr">[]</code>. هذا شائع جدًا في الكلاسات التي تعمل كحاويات (<code class="type">containers</code>) مثل المصفوفات والمتجهات لتوفير وصول بديهي إلى العناصر.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 210: تأثير الـ Private Inheritance على الوصول</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكود يوضح الوراثة الخاصة. <code class="keyword">Class B</code> يرث من <code class="keyword">A</code> بشكل <code class="keyword">private</code>، و <code class="keyword">Class C</code> يرث من <code class="keyword">B</code>. </p>
                    <ul>
                        <li><code class="keyword">M1</code>: كانت <code class="keyword">public</code> في <code class="keyword">A</code>، وأصبحت <code class="keyword">private</code> في <code class="keyword">B</code>. لذلك لا يمكن استدعاؤها من <code class="keyword">main</code>.</li>
                        <li><code class="keyword">M4</code>: تحاول الوصول إلى <code class="keyword">y</code> و <code class="keyword">z</code>، وهي أعضاء خاصة في <code class="keyword">B</code> (موروثة من <code class="keyword">A</code>)، وهذا غير مسموح به من <code class="keyword">C</code>.</li>
                    </ul>
                    <div class="answer false"><strong>النتيجة:</strong> ستحدث أخطاء ترجمة (<code class="type">Compilation Error</code>) في الأسطر 3, 4, 6.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 211: الـ Constructors المطلوبة في الوراثة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>إذا لم يقم <code class="keyword">constructor</code> الكلاس المشتق باستدعاء <code class="keyword">constructor</code> الكلاس الأساسي بشكل صريح، فسيحاول المترجم استدعاء الـ <code class="type">default constructor</code> (الذي لا يأخذ وسائط) للكلاس الأساسي.</p>
                    <ul>
                        <li><code dir="ltr">Child(int x)</code>: يحاول استدعاء <code dir="ltr">Base()</code> ضمنيًا.</li>
                        <li><code dir="ltr">Child(int x, int y) : Base(x,y)</code>: يستدعي <code dir="ltr">Base(int, int)</code> صراحة.</li>
                    </ul>
                    <p>لكي يعمل الكود، يجب أن يتوفر كلا الـ <code class="keyword">constructors</code> في الكلاس <code class="keyword">Base</code>.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> <code dir="ltr">Base()</code> و <code dir="ltr">Base(int, int)</code> يجب أن يكونا موجودين.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 212: توقع الـ Output لكود Abstract Classes</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال معقد يوضح سلسلة من الوراثة والتجريد.</p>
                    <ul>
                        <li><code class="keyword">GrandFather</code>: مجرد (Abstract).</li>
                        <li><code class="keyword">Parent</code>: يرث من <code class="keyword">GrandFather</code>، يعيد تعريف <code dir="ltr">displayStuff</code> ولكنه لا يعيد تعريف <code dir="ltr">sayThings</code>، لذا يظل مجردًا.</li>
                        <li><code class="keyword">Child</code>: يرث من <code class="keyword">Parent</code>، يعيد تعريف <code dir="ltr">sayThings</code>. بما أنه تم تعريف جميع الدوال النقية في السلسلة، يصبح <code class="keyword">Child</code> كلاسًا ملموسًا (<code class="type">concrete</code>).</li>
                        <li><code class="keyword">GrandChild</code>: يرث من <code class="keyword">Child</code> وهو أيضًا ملموس.</li>
                    </ul>
                    <p>لا يمكن إنشاء كائنات من <code class="keyword">GrandFather</code> أو <code class="keyword">Parent</code>. الكود في المستند سيطبع مخرجات من الكائنات الملموسة.</p>
                    <div class="answer"><strong>النتيجة:</strong> سيحدث خطأ في الترجمة عند محاولة إنشاء كائنات من الكلاسات المجردة.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 213: وظيفة <code>new float(15)</code></span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 13). التعبير <code dir="ltr">new float(15)</code> يقوم بتخصيص ذاكرة لمتغير واحد من نوع <code class="type">float</code> ويهيئه بالقيمة 15.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Allocate space for a float variable that is initialized to 15.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 215: توقع الـ Output لكود Pass by Value و Copy Constructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدالة <code dir="ltr">show</code> تأخذ وسيطها بالقيمة (<code class="type">pass by value</code>). هذا يعني أنه عند استدعاء <code dir="ltr">show(n1)</code>، سيتم إنشاء نسخة من <code dir="ltr">n1</code> باستخدام الـ <code class="keyword">copy constructor</code>.</p>
                    <ol>
                        <li><b><code dir="ltr">Card n1;</code>:</b> يستدعي الـ <code class="type">default constructor</code> ويطبع "I am the default constructor".</li>
                        <li><b><code dir="ltr">n1.setA(15);</code>:</b> يضبط القيمة.</li>
                        <li><b><code dir="ltr">show(n1);</code>:</b> يستدعي الـ <code class="keyword">copy constructor</code> لإنشاء نسخة، فيطبع "I am the copy constructor".</li>
                        <li>داخل <code dir="ltr">show</code>، يتم طباعة قيمة العضو <code dir="ltr">a</code> للكائن المنسوخ.</li>
                    </ol>
                    <div class="answer"><strong>الناتج:</strong> سيتم طباعة رسائل من كلا الـ constructors. العلاقة بين الكائنات هنا هي <code class="type">Association</code> لأن الدالة "تستخدم" كائنًا.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 217: هل يرث الكلاس المشتق الأعضاء الخاصة؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة تقول أن <code class="keyword">Child class</code> يرث الأعضاء الخاصة (<code class="keyword">private members</code>) من <code class="keyword">Parent class</code> بحيث يمكنه استخدامها مباشرة. هذا <b>خطأ</b>.</p>
                    <p>الأعضاء الخاصة لا يتم وراثتها بمعنى أن الكلاس المشتق لا يمكنه الوصول إليها مباشرة. العلاقة الموصوفة بين <code class="keyword">Lecture</code> و <code class="keyword">Instructor</code> هي مثال على <code class="type">Aggregation</code> وليس <code class="type">Inheritance</code>.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 220: تعريف علاقة الـ Composition</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>التكوين (<code class="type">Composition</code>) هو علاقة "has-a" قوية. إنه يمثل علاقة "جزء من" (<code class="type">part-of</code>) حيث تكون دورة حياة الكائن المحتوى ("الجزء") مرتبطة ارتباطًا وثيقًا بدورة حياة الكائن الحاوي ("الكل"). إذا تم تدمير "الكل"، يتم تدمير "الجزء" معه.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Before the body of the constructor of class M is executed (لأن الجزء يجب أن يُنشأ قبل الكل).</div>
                </div>
            </div>

        </div>
    </div>


      <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء الثاني عشر: 221-240)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 222: عبارات صحيحة عن الـ Constructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 50).</p>
                    <ul>
                        <li><b>A. A constructor can not be overloaded:</b> <b>خطأ</b>. يمكن إعادة تحميله.</li>
                        <li><b>B. A constructor is a special member function...:</b> <b>صحيح</b>. وظيفته تهيئة الموارد عند إنشاء الكائن والتأكد من تحريرها عند تدميره.</li>
                    </ul>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> B.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 223: تأثير Private Inheritance على الوصول</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا السؤال غير مكتمل في المصدر، لكنه يتعلق بالوراثة الخاصة وتأثيرها على الوصول إلى الأعضاء.</p>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 224: هل الـ Constructor مسؤول عن إزالة الكائن؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "الـ constructor مسؤول عن إزالة الكائن من الذاكرة" هي <b>خاطئة</b>.</p>
                    <p>الـ <code class="keyword">constructor</code> مسؤول عن تهيئة (<code class="keyword">initialize</code>) الكائن. الـ <code class="keyword">destructor</code> هو المسؤول عن تنظيف الموارد (<code class="keyword">clean up</code>) قبل تدمير الكائن. عملية إزالة الذاكرة نفسها (<code class="type">deallocation</code>) تتم تلقائيًا للكائنات على المكدس أو يدويًا باستخدام <code class="keyword">delete</code> للكائنات على الكومة.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 225: هل Multilevel Inheritance مسموحة في C++؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة تقول أن الوراثة متعددة المستويات (<code class="type">Multilevel Inheritance</code>) غير مسموحة. هذه العبارة <b>خاطئة</b>.</p>
                    <p>لغة C++ تدعم الوراثة متعددة المستويات بشكل كامل، وهي مفهوم أساسي في البرمجة كائنية التوجه.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 226: علاقة Association و Composition</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "Association هو نوع خاص من Composition" هي <b>خاطئة</b>. (مكرر للسؤال 200).</p>
                    <p>العكس هو الصحيح. <code class="type">Composition</code> هو نوع خاص وأكثر تقييدًا من <code class="type">Association</code>. الـ <code class="type">Composition</code> يمثل علاقة "part-of" قوية حيث تعتمد دورة حياة الجزء على الكل.</p>
                    <div class="answer true"><strong>العبارة في المصدر "معكوسة":</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 228: وصول الأعضاء الموروثة في Derived Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلاس المشتق (<code class="keyword">derived class</code>) يرث الأعضاء الخاصة (<code class="keyword">private members</code>) من الكلاس الأساسي، لكنه لا يستطيع الوصول إليها مباشرة. العبارة "متقدرش توصلهم مباشرة باسمهم" صحيحة.</p>
                    <p>الدالة الصديقة (<code class="keyword">Friend Function</code>) يمكنها الوصول إلى جميع الأعضاء (private, protected, public). العبارة "وصول فقط لـ Private Members" تجعلها خاطئة.</p>
                    <div class="answer false"><strong>العبارة العامة في المستند:</strong> خاطئة (False).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 230: توقع الـ Output لكود for loop</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الحلقة <code class="keyword">for</code> تبدأ من <code dir="ltr">i = 10</code>، وتستمر طالما <code dir="ltr">i >= 0</code>، وتنقص <code dir="ltr">i</code> بمقدار 5 في كل دورة.</p>
                    <ul>
                        <li><b>عندما <code dir="ltr">i = 10</code>:</b> يطبع 10، ثم نتيجة <code dir="ltr">10 - (10 - 1) = 1</code>.</li>
                        <li><b>عندما <code dir="ltr">i = 5</code>:</b> يطبع 5، ثم نتيجة <code dir="ltr">10 - (5 - 1) = 6</code>.</li>
                        <li><b>عندما <code dir="ltr">i = 0</code>:</b> يطبع 0، ثم نتيجة <code dir="ltr">10 - (0 - 1) = 11</code>.</li>
                    </ul>
                    <p>تتوقف الحلقة بعد ذلك. المخرج في المستند <code dir="ltr">i = 1 i = 6 1 = 11</code> غير واضح، لكنه يبدو أنه يمثل نتائج المعادلات فقط.</p>
                    <div class="output"><strong>نتائج المعادلات هي:</strong> 1, 6, 11.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 231: تعريف الـ Destructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الـ <code class="keyword">Destructor</code> هو دالة عضو خاصة تُستدعى تلقائيًا عندما يتم تدمير كائن. دوره الأساسي هو تحرير الموارد (<code class="type">clean up resources</code>) التي حجزها الكائن، مثل الذاكرة المخصصة بـ <code class="keyword">new</code> أو إغلاق الملفات. هو لا يقوم بإلغاء تخصيص ذاكرة الكائن نفسه، بل ينظف ما بداخله.</p>
                    <div class="answer"><strong>الوصف:</strong> صحيح.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 232: قيمة x بعد انتهاء while loop</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الحلقة تستمر طالما <code dir="ltr">x < 11</code>. (بافتراض <code dir="ltr">x=0, y=4</code> في البداية).</p>
                    <ul>
                        <li><b>الدورة 1:</b> <code dir="ltr">y</code> تصبح 3. <code dir="ltr">x</code> تصبح <code dir="ltr">0 + 2*3 = 6</code>.</li>
                        <li><b>الدورة 2:</b> <code dir="ltr">y</code> تصبح 2. <code dir="ltr">x</code> تصبح <code dir="ltr">6 + 2*2 = 10</code>.</li>
                        <li><b>الدورة 3:</b> <code dir="ltr">y</code> تصبح 1. <code dir="ltr">x</code> تصبح <code dir="ltr">10 + 2*1 = 12</code>.</li>
                    </ul>
                    <p>تتوقف الحلقة لأن <code dir="ltr">12</code> ليست أقل من 11.</p>
                    <div class="output"><strong>القيمة النهائية لـ x هي:</strong> 12.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 233: الوصول لعنصر في 2D Array</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>للوصول إلى عنصر في مصفوفة ثنائية الأبعاد، نستخدم فهرس الصف ثم فهرس العمود. الفهرسة تبدأ من 0.</p>
                    <p>للوصول إلى القيمة 4 في المصفوفة <code dir="ltr">{{1,2,3},{4,5,6},{7,8,9}}</code>:</p>
                    <ul>
                        <li>هي في الصف الثاني (فهرس 1).</li>
                        <li>هي في العمود الأول (فهرس 0).</li>
                    </ul>
                    <div class="answer"><strong>طريقة الوصول:</strong> <code dir="ltr">Arr[1][0]</code>.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 234: وظيفة الـ Compiler</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة تصف الـ <code class="type">Interpreter</code> (المفسر) الذي يترجم وينفذ الكود سطرًا بسطر.</p>
                    <p>الـ <code class="type">Compiler</code> (المترجم) يقوم بترجمة الكود المصدري بالكامل مرة واحدة إلى ملف تنفيذي (<code class="keyword">executable file</code>) قبل التشغيل.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 235: استخدام الـ Static Members</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الأعضاء الثابتة (<code class="keyword">static members</code>) يمكن استخدامها في كل من الدوال الثابتة (<code class="keyword">static methods</code>) والدوال غير الثابتة (<code class="keyword">non-static / instance methods</code>) داخل نفس الكلاس.</p>
                    <div class="answer true"><strong>العبارة "مش لازم تستخدم بس في الـ static methods":</strong> صحيحة.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 236: أنواع البيانات في switch statement</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>جملة <code class="keyword">switch</code> في C++ تعمل مع أنواع البيانات الصحيحة (<code class="type">integral types</code>) والتي تشمل <code class="type">int</code>, <code class="type">char</code>, <code class="type">short</code>, <code class="type">long</code>، بالإضافة إلى <code class="type">enum types</code>.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 237: استخدام الـ Inheritance</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الوراثة (<code class="keyword">Inheritance</code>) هي آلية لتوسيع (<code class="type">extending</code>) كلاس أساسي. الكلاس المشتق يرث أعضاء الكلاس الأساسي ويمكنه إضافة أعضاء جديدة خاصة به لزيادة الوظائف (<code class="type">functionality</code>).</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 238: عودة التحكم بعد انتهاء الدالة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عندما تنتهي دالة من تنفيذها (سواء بالوصول إلى نهايتها أو عند جملة <code class="keyword">return</code>)، يعود التحكم في تنفيذ البرنامج دائمًا إلى النقطة التي تم استدعاء الدالة منها (<code class="type">the caller</code>).</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 239: تعريف الـ Abstract Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "الكلاس الذي به دالة افتراضية ليس دائمًا مجردًا" هي <b>صحيحة</b>. لكي يكون الكلاس مجردًا (<code class="type">abstract</code>)، يجب أن يحتوي على دالة افتراضية نقية (<code class="keyword">pure virtual function</code>) واحدة على الأقل.</p>
                    <div class="answer false"><strong>العبارة في المستند:</strong> خاطئة (False)، ولكن هذا يبدو خطأ في المستند نفسه لأن التحليل صحيح.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 240: توقع الـ Output لكود Class و Global Function</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عند استدعاء <code dir="ltr">x.printITI()</code>، يتم استدعاء الدالة العضو (<code class="keyword">member function</code>) الخاصة بالكائن <code dir="ltr">x</code>، والتي تطبع "ITI".</p>
                    <p>الدالة العامة (<code class="keyword">global function</code>) التي تحمل نفس الاسم لا يتم استدعاؤها أبدًا. (ملاحظة: وجودها قد يسبب خطأ في بعض الحالات إذا لم تكن المعلمات مختلفة، ولكن في هذا السياق، يتم استدعاء دالة الكائن).</p>
                    <div class="output"><strong>الـ Output هو:</strong> "ITI".</div>
                </div>
            </div>

        </div>
    </div>

     <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء الثالث عشر: 241-260)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 241: ميعاد استدعاء Constructor الـ Base Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 12 و 28). عند إنشاء كائن من كلاس مشتق، يتم دائمًا استدعاء الـ <code class="keyword">constructor</code> الخاص بالكلاس الأساسي (<code class="keyword">Base Class</code>) <b>قبل</b> أن يبدأ الـ <code class="keyword">constructor</code> الخاص بالكلاس المشتق في التنفيذ. هذا يضمن تهيئة الجزء الأساسي من الكائن أولاً.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> قبل ما الـ Constructor بتاع الـ Derived Class يبدأ يشتغل.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 242: توقع الـ Output لكود switch statement</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكود يقوم بفحص قيمة المتغير <code dir="ltr">x</code>، وهي 35. جملة <code class="keyword">switch</code> لا تحتوي على <code class="keyword">case</code> يطابق القيمة 35.</p>
                    <p>في هذه الحالة، سيتم تنفيذ الكتلة الافتراضية (<code class="keyword">default block</code>)، والتي ستقوم بطباعة "value of X is: 35".</p>
                    <div class="output"><strong>الـ Output هو:</strong> value of X is: 35.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 243: تعريف الـ Multilevel Inheritance</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الوراثة متعددة المستويات (<code class="type">Multilevel Inheritance</code>) هي سلسلة من الوراثة حيث يرث كلاس من كلاس آخر هو نفسه مشتق من كلاس ثالث (مثلاً: <code dir="ltr">A -> B -> C</code>).</p>
                    <p>هذه الميزة مدعومة بالكامل في لغة C++.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 244: أنواع عناصر الـ Array</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>في C++، يجب أن تكون جميع العناصر في مصفوفة (<code class="keyword">array</code>) من نفس نوع البيانات (<code class="type">data type</code>). هذا هو أحد التعريفات الأساسية للمصفوفة: مجموعة متجانسة من العناصر.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 245: هل يمكن لـ Pointer من Derived Class أن يشير إلى Base Class؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "مؤشر من نوع الكلاس المشتق لا يمكنه أن يشير إلى كائن من الكلاس الأساسي" هي <b>صحيحة</b>. هذا لأن الكلاس الأساسي لا يحتوي بالضرورة على جميع الأعضاء الموجودة في الكلاس المشتق.</p>
                    <p>العكس هو الصحيح: مؤشر من نوع الكلاس الأساسي يمكنه أن يشير إلى كائن من الكلاس المشتق (وهذا هو أساس تعدد الأشكال).</p>
                    <div class="answer false"><strong>العبارة في المستند:</strong> خاطئة (False). (المستند يصف العكس، مما يجعل العبارة الأصلية صحيحة).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 246: تنفيذ do-while Loop</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>حلقة <code class="keyword">do-while</code> هي حلقة يتم التحكم فيها عند الخروج (<code class="type">exit-controlled loop</code>). هذا يعني أن جسم الحلقة (<code class="keyword">loop body</code>) يتم تنفيذه مرة واحدة على الأقل قبل التحقق من الشرط.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 247: وصول الـ Derived Class لأعضاء الـ Base Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "الكلاس المشتق لا يصل فقط للأعضاء المحمية" هي <b>صحيحة</b>.</p>
                    <p>يمكن للكلاس المشتق الوصول إلى الأعضاء العامة (<code class="keyword">public</code>) والمحمية (<code class="keyword">protected</code>) للكلاس الأساسي. لا يمكنه الوصول إلى الأعضاء الخاصة (<code class="keyword">private</code>).</p>
                    <div class="answer false"><strong>العبارة في المستند:</strong> خاطئة (False)، ولكن هذا يبدو خطأ في المستند لأن التحليل صحيح.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 248: تغيير حجم الـ Array في وقت التشغيل</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>حجم المصفوفات القياسية بأسلوب C (مثل <code dir="ltr">int arr[10];</code>) يجب أن يكون ثابتًا ومعروفًا في وقت الترجمة (<code class="type">compile time</code>) ولا يمكن تغييره أثناء تنفيذ البرنامج.</p>
                    <p>لتغيير الحجم ديناميكيًا، يجب استخدام تخصيص الذاكرة الديناميكي (مثل <code class="keyword">new[]</code> و <code class="keyword">delete[]</code>) أو استخدام حاويات المكتبة القياسية مثل <code class="type">std::vector</code>.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 249: استخدام الـ Pure Virtual Function</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>نستخدم الدوال الافتراضية النقية (<code class="keyword">pure virtual function</code>) لإنشاء "عقد" (<code class="type">contract</code>) في الكلاس الأساسي. هذا العقد يجبر أي كلاس مشتق ملموس على توفير تطبيق (<code class="keyword">implementation</code>) لهذه الدالة. هذا هو أساس إنشاء الواجهات (<code class="type">interfaces</code>) والكلاسات المجردة.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Overriding دالة موروثة من base class في الـ derived class.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 250: عدد مرات تنفيذ x=1 في Nested Loops</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>يوجد خطأ شائع في الكود: كلتا الحلقتين (الداخلية والخارجية) تستخدمان نفس متغير العداد <code dir="ltr">j</code>.
                    <ol>
                        <li>الحلقة الخارجية تبدأ بـ <code dir="ltr">j=0</code>.</li>
                        <li>الحلقة الداخلية تعمل من <code dir="ltr">j=0</code> إلى <code dir="ltr">j < n</code>. أثناء ذلك، يتم تنفيذ <code dir="ltr">x=1</code> عدد <code dir="ltr">n</code> من المرات.</li>
                        <li>عندما تنتهي الحلقة الداخلية، تكون قيمة <code dir="ltr">j</code> هي <code dir="ltr">n</code>.</li>
                        <li>تعود السيطرة إلى الحلقة الخارجية، التي تتحقق من شرطها <code dir="ltr">j < n</code>. بما أن <code dir="ltr">j</code> الآن تساوي <code dir="ltr">n</code>، فإن الشرط يكون <code class="keyword">false</code>، وتنتهي الحلقة الخارجية بعد دورة واحدة فقط.</li>
                    </ol>
                    <div class="output"><strong>النتيجة:</strong> سيتم تنفيذ <code dir="ltr">x=1</code> عدد <code dir="ltr">n</code> مرات.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 251: إظهار Data Member للبرنامج</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لجعل عضو بيانات (<code class="keyword">data member</code>) في كلاس متاحًا للوصول إليه من أي مكان خارج الكلاس، يجب إعلانه في القسم العام (<code class="keyword">public section</code>) باستخدام محدد الوصول <code class="keyword">public</code>.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Public.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 252: Function Overloading</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>لإعادة تحميل دالة (<code class="keyword">function overload</code>)، يجب أن تكون قائمة الوسائط (<code class="keyword">parameter list</code>) مختلفة. لا يكفي أن يكون نوع الإرجاع (<code class="keyword">return type</code>) مختلفًا فقط.</p>
                    <ul>
                        <li><b>الخيار a:</b> غير صالح لأنه يختلف فقط في نوع الإرجاع.</li>
                        <li><b>الخيار b:</b> صالح لأن قائمة الوسائط مختلفة (<code dir="ltr">int, char</code> مقابل <code dir="ltr">double, char</code>).</li>
                    </ul>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> (b) فقط.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 253: تعريف الـ Pass by Value</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>عند تمرير متغير بالقيمة (<code class="type">pass by value</code>)، يتم إنشاء نسخة (<code class="type">copy</code>) من قيمة المتغير وتمريرها إلى الدالة. أي تغييرات يتم إجراؤها على هذه النسخة داخل الدالة لا تؤثر على المتغير الأصلي خارجها.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> by value.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 254: الوصول لـ Private و Protected Members</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>في الكود، <code dir="ltr">int x;</code> يكون <code class="keyword">private</code> افتراضيًا لأنه لم يسبقه محدد وصول. <code dir="ltr">int y;</code> مُعلن كـ <code class="keyword">protected</code>.</p>
                    <p>لا يمكن الوصول إلى الأعضاء الخاصة أو المحمية مباشرة من خارج الكلاس (مثل دالة <code class="keyword">main</code>). أي محاولة للوصول إلى <code dir="ltr">x</code> أو <code dir="ltr">y</code> من <code class="keyword">main</code> ستؤدي إلى خطأ في الترجمة (<code class="type">compilation error</code>).</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> An error, x is private. و An error, y is protected.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 255: متى لا يُنصح باستخدام inline Function</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "لا يُنصح بجعل الدالة inline عندما تُرجع قيمة" هي <b>خاطئة</b>.</p>
                    <p>لا توجد علاقة مباشرة بين كون الدالة تُرجع قيمة وكونها مرشحة جيدة لـ <code class="keyword">inline</code>. التوصية بعدم استخدام <code class="keyword">inline</code> تكون للدوال الكبيرة، أو المعقدة (التي تحتوي على حلقات أو استدعاء ذاتي)، لأن تضمينها قد يزيد من حجم الكود دون فائدة في الأداء.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 256: وراثة أعضاء الـ Parent Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلاس المشتق (<code class="keyword">child class</code>) يرث جميع أعضاء الكلاس الأساسي، ولكن يمكنه الوصول مباشرة فقط إلى الأعضاء العامة (<code class="keyword">public</code>) والمحمية (<code class="keyword">protected</code>).</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 257: تعريف الـ Abstract Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الكلاس الذي يحتوي على دالة افتراضية نقية (<code class="keyword">pure virtual function</code>) واحدة على الأقل يُسمى كلاسًا مجردًا (<code class="type">Abstract Class</code>). لا يمكنك إنشاء كائنات مباشرة من هذا الكلاس.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 258: هل يجب عمل override لـ virtual function؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>العبارة "يجب عمل override للدوال الافتراضية العادية" هي <b>خاطئة</b>.</p>
                    <p>إذا كانت الدالة افتراضية عادية (<code class="keyword">regular virtual function</code>)، فلديها تطبيق في الكلاس الأساسي. الكلاس المشتق ليس مجبرًا على إعادة تعريفها؛ إذا لم يفعل، فسوف يرث ببساطة تطبيق الكلاس الأساسي.</p>
                    <p>فقط الدوال الافتراضية النقية (<code class="keyword">pure virtual function</code>) هي التي يجب إعادة تعريفها في الكلاس المشتق الملموس.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 259: هل يمكن لمؤشر Base Class أن يشير إلى Derived Class؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p><b>نعم</b>، يمكن لمؤشر من نوع الكلاس الأساسي (<code dir="ltr">Base Class*</code>) أن يشير إلى كائن من أي من كلاساته المشتقة (<code class="keyword">Derived Class</code>). هذا هو المبدأ الأساسي الذي يتيح تعدد الأشكال (Polymorphism) في C++.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 260: وظيفة <code>new int[5]</code></span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>التعبير <code dir="ltr">new int[5]</code> يقوم بتخصيص ذاكرة ديناميكيًا على الكومة (<code class="keyword">heap</code>) لمصفوفة تتسع لخمسة عناصر من نوع <code class="type">int</code>.</p>
                    <p>عند استخدام هذه الصيغة مع أنواع البيانات الأساسية (مثل <code class="type">int</code>)، لا يتم تهيئة عناصر المصفوفة، وستحتوي على قيم عشوائية (<code class="type">garbage values</code>).</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> Allocate for an array of integers of 5 elements that is not initialized.</div>
                </div>
            </div>
            
        </div>
    </div>

     <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء الرابع عشر: 261-280)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 261: ما الذي تسمح به الـ Virtual Functions؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>الدوال الافتراضية (<code class="keyword">Virtual Functions</code>) هي الآلية التي تحقق تعدد الأشكال في وقت التشغيل (<code class="type">runtime polymorphism</code>). إنها تسمح لك باستخدام نفس استدعاء الدالة (عبر مؤشر من الكلاس الأساسي) لتنفيذ إصدارات مختلفة من الدالة بناءً على النوع الفعلي للكائن الذي يشير إليه المؤشر.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> use the same function call to execute member functions of objects from different classes.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 262: توقع الـ Output لكود Copy Constructor and Increment</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر. يتعلق بالكود الذي يوضح سلوك الـ Copy Constructor والزيادة (Increment). بناءً على التحليل السابق، الكود سيطبع "1 2 2"، ولكن المستند قد يدمج الأرقام.</p>
                    <p>الخيارات المتاحة (B, C, D) تتعلق بصلاحية إعادة التحميل، وهو ما تم تناوله في السؤال 177.</p>
                    <div class="answer false"><strong>العبارة في المستند:</strong> خاطئة (False).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 263: وصول الـ Protected Members من خارج الكلاس</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>من منظور كود خارج التسلسل الهرمي للوراثة (مثل دالة <code class="keyword">main</code>)، يتصرف العضو المحمي (<code class="keyword">protected</code>) تمامًا مثل العضو الخاص (<code class="keyword">private</code>). لا يمكن الوصول إليه مباشرة.</p>
                    <p>الوصول الخاص به متاح فقط للكلاس نفسه وللكلاسات المشتقة منه.</p>
                    <div class="answer"><strong>الإجابة الصحيحة هي:</strong> private member.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 264: تصميم Shapes و Picture (Inheritance and Composition)</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال تصميمي يتطلب استخدام الوراثة والتكوين معًا:</p>
                    <ol>
                        <li><b>الكلاسات:</b>
                            <ul>
                                <li>كلاس أساسي <code class="keyword">Shape</code> (مجرد).</li>
                                <li>كلاسات مشتقة <code class="keyword">Circle</code>, <code class="keyword">Triangle</code>, <code class="keyword">Rectangle</code>.</li>
                                <li>كلاس حاوي <code class="keyword">Picture</code>.</li>
                            </ul>
                        </li>
                        <li><b>العلاقات:</b>
                            <ul>
                                <li>العلاقة بين <code class="keyword">Shape</code> والكلاسات المشتقة هي وراثة (<code class="type">Inheritance</code> - is-a).</li>
                                <li>العلاقة بين <code class="keyword">Picture</code> و <code class="keyword">Shape</code> هي تكوين (<code class="type">Composition</code> - has-a)، حيث تحتوي الصورة على مجموعة من الأشكال.</li>
                            </ul>
                        </li>
                    </ol>
                    <div class="answer"><strong>الحل:</strong> يتضمن إنشاء هذه الكلاسات والعلاقات بينها.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 265: Polymorphism كـ Function Overloading</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 180). إعادة تحميل الدوال (<code class="keyword">Function Overloading</code>) هي شكل من أشكال تعدد الأشكال في وقت الترجمة (<code class="type">compile-time polymorphism</code>).</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 266: هل الـ Constructor مسؤول عن إزالة الكائن؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 224). العبارة <b>خاطئة</b>. الـ <code class="keyword">constructor</code> مسؤول عن التهيئة، بينما الـ <code class="keyword">destructor</code> مسؤول عن تنظيف الموارد.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 267: هل Multilevel Inheritance مسموحة في C++؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 225). العبارة <b>خاطئة</b>. لغة C++ تدعم الوراثة متعددة المستويات بشكل كامل.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 268: علاقة Association و Composition</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 200 و 226). العبارة "Association هو نوع خاص من Composition" هي <b>خاطئة</b>. العكس هو الصحيح.</p>
                    <div class="answer true"><strong>العبارة في المستند "معكوسة":</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 269: أي كائن يمكنه استقبال الرسائل</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 184). يمكن للكائن استقبال الرسائل (استدعاء الدوال) المعرفة في كلاسه أو في أي من كلاساته الأساسية. العبارة صحيحة في هذا السياق.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 270: وصول الأعضاء الموروثة في Derived Class</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 228). الكلاس المشتق يرث الأعضاء الخاصة لكنه لا يستطيع الوصول إليها مباشرة. والدالة الصديقة تصل إلى جميع الأعضاء (private, protected, public).</p>
                    <div class="answer false"><strong>العبارة العامة في المستند:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 271: المصطلح الصحيح لإضافة وظائف لـ Operator</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 186). المصطلح الصحيح هو <code class="type">Operator Overloading</code> (إعادة تحميل المعامل). <code class="type">Overriding</code> يستخدم للدوال في الوراثة.</p>
                    <div class="answer"><strong>المصطلح الصحيح:</strong> Operator Overloading.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 273: وصول الأعضاء المحمية في الوراثة الخاصة</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 188). يمكن للكلاس المشتق دائمًا الوصول إلى الأعضاء العامة والمحمية من كلاسه الأساسي المباشر، بغض النظر عن نمط الوراثة.</p>
                    <div class="answer false"><strong>العبارة في المستند:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 274: هل this Pointer هو array of pointers؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 174). العبارة <b>خاطئة</b>. المؤشر <code class="keyword">this</code> هو مؤشر واحد (<code class="type">single pointer</code>).</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 275: أي دالة يمكنها التعامل مع Instance Variables</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 190). الدوال العضو غير الثابتة (<code class="type">non-static instance methods</code>) هي التي يمكنها التعامل مع متغيرات النسخة (<code class="type">Instance Variables</code>).</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 276: وصول الأعضاء المحمية</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 191). العضو المحمي يمكن الوصول إليه من الكلاس نفسه ومن الكلاسات المشتقة. استخدام الـ <code class="type">getters</code> و <code class="type">setters</code> يوفر واجهة عامة متحكم بها للوصول إلى البيانات الخاصة أو المحمية.</p>
                    <div class="answer true"><strong>العبارة:</strong> صحيحة (True).</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 278: هل كل كائنات نفس الكلاس لها علاقة is-a؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 193). العبارة <b>خاطئة</b>. علاقة "is-a" تصف الوراثة بين الكلاسات، وليس بين الكائنات.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 279: توقع الـ Output لكود Copy Constructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا الكود يختبر سلوك الـ <code class="keyword">copy constructor</code> مع الزيادة السابقة (<code class="type">pre-increment</code>).</p>
                    <ol>
                        <li><b><code dir="ltr">Test x(t)</code>:</b> يتم استدعاء <code class="keyword">copy constructor</code>.</li>
                        <li><b><code dir="ltr">x = ++r.x</code>:</b> يتم زيادة <code dir="ltr">r.x</code> (وهو <code dir="ltr">t.x</code>) أولاً. إذا كانت قيمة <code dir="ltr">t.x</code> الأولية هي 1، فإنها تصبح 2.</li>
                        <li>ثم يتم إسناد القيمة الجديدة (2) إلى <code dir="ltr">x.x</code>.</li>
                        <li>بعد ذلك، كل من <code dir="ltr">t.x</code> و <code dir="ltr">x.x</code> سيكونان 2.</li>
                    </ol>
                    <p>الناتج الإجمالي في المستند 122 يبدو أنه ناتج من سلسلة من العمليات مشابهة للسؤال 21.</p>
                    <div class="output"><strong>الـ Output هو:</strong> 122.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 280: توقع الـ Output لكود Protected Inheritance Access</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا السؤال غير مكتمل في المصدر ويشير إلى أنه نفس السؤال رقم 58. يتعلق بقواعد الوصول في الوراثة المحمية (<code class="keyword">protected inheritance</code>).</p>
                </div>
            </div>
        </div>
    </div>


    <div class="container">
        <h1>مراجعة أسئلة البرمجة (الجزء الأخير: 281-292)</h1>
        <div class="accordion">
        
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 282: العلاقة بين Class Monkey و Class Animal</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 197). العلاقة "Monkey is an Animal" هي علاقة وراثة (<code class="type">Inheritance</code>). العبارة التي تقول أنها <code class="type">association</code> هي <b>خاطئة</b>.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 283: توقع الـ Output لكود Static Member Initialization & Constructor</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا السؤال يشير إلى أنه نفس السؤال 67. يتعلق بقواعد تهيئة الأعضاء الثابتة (<code class="keyword">static members</code>) واستدعاء المُنشئات (<code class="keyword">constructors</code>)، وغالبًا ما يؤدي إلى خطأ في الترجمة إذا لم تتم التهيئة بشكل صحيح.</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compilation Error at Line 4.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 284: توقع الـ Output لكود Friend Function Access</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا السؤال يشير إلى أنه نفس السؤال 242 (المتعلق بـ virtual vs non-virtual) والسؤال 66. بناءً على تحليل السؤال 66:</p>
                    <ul>
                        <li>الدالة غير الافتراضية ستطبع 4.</li>
                        <li>الدالة الافتراضية ستطبع 27.</li>
                    </ul>
                    <div class="output"><strong>الـ Output هو:</strong> 4 27.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 287: الـ Constructors المطلوبة في Base Class مع Inheritance</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 245 و 211 و 308). يتعلق بضرورة استدعاء مُنشئ الكلاس الأساسي من الكلاس المشتق.</p>
                    <p>الإجابة في المستند تشير إلى تخصيص ذاكرة لـ <code class="type">float</code> غير مهيأ، مما قد يكون إجابة لسؤال مختلف. بناءً على عنوان السؤال، الإجابة تتعلق بضرورة وجود الـ constructors المناسبة في الكلاس الأساسي.</p>
                    <div class="answer"><strong>الإجابة:</strong> Allocate space for a variable.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 288: تصميم Classes لـ Airlines Company Information System</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 172). يتعلق بتصميم نظام باستخدام الوراثة. العبارة في المستند التي تقول إنها ليست وراثة متعددة المستويات صحيحة، ولكن الحكم على العبارة العامة بـ <code class="keyword">False</code> قد يكون مربكًا.</p>
                    <div class="answer false"><strong>العبارة:</strong> خاطئة (False).</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 290: هل this Pointer هو array of pointers؟</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 174 و 232 و 274). العبارة <b>خاطئة</b>. المؤشر <code class="keyword">this</code> هو مؤشر واحد (<code class="type">single pointer</code>)، وليس مصفوفة.</p>
                    <div class="answer true"><strong>العبارة في المستند:</strong> صحيحة (True). هذا يبدو تناقضًا مع الإجابات السابقة. الإجابة الصحيحة هي أن <code class="keyword">this</code> هو مؤشر واحد، فالعبارة التي تقول إنه مصفوفة هي خاطئة.</div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 291: توقع الـ Output لكود Abstract Classes و Pure Virtual Functions</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا السؤال يشير إلى أنه نفس السؤال 212. سيحدث خطأ في الترجمة (<code class="type">Compilation Error</code>) عند محاولة إنشاء كائنات من الكلاسات المجردة (<code class="keyword">Abstract Classes</code>) التي لم تقم بتطبيق جميع الدوال الافتراضية النقية.</p>
                    <div class="answer false"><strong>الـ Output هو:</strong> Compiler Error at Line 1 و Compiler Error at Line 2.</div>
                </div>
            </div>
            
            <div class="accordion-item">
                <button class="accordion-header">
                    <span class="question-title">السؤال 292: توقع الـ Output لكود Static Members and Functions</span>
                    <span class="icon">+</span>
                </button>
                <div class="accordion-body">
                    <p>هذا سؤال مكرر (رقم 59 و 250). يتعلق بسلوك الأعضاء الثابتة (<code class="keyword">static</code>) وأعضاء الكائن (<code class="keyword">instance</code>).</p>
                    <ul>
                        <li><code dir="ltr">obj.x</code> (عضو كائن) ستكون قيمته 15.</li>
                        <li><code dir="ltr">myT.x</code> (عضو ثابت) ستكون قيمته 7.</li>
                        <li><code dir="ltr">Tester::var</code> (عضو ثابت آخر غير مهيأ) ستكون قيمته 0.</li>
                    </ul>
                    <div class="output"><strong>الـ Output هو:</strong> 15 7 0.</div>
                </div>
            </div>

        </div>
        
        <div style="text-align: center; margin-top: 40px; padding: 20px; background-color: #e9f7ef; border-radius: 8px;">
            <h2 style="color: var(--success-color);">اكتملت المراجعة!</h2>
            <p>لقد قمنا بتغطية جميع الأسئلة من 1 إلى 292. أتمنى لك كل التوفيق!</p>
        </div>

    </div>



    <script>
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.addEventListener('click', () => {
                const accordionItem = header.parentElement;
                const accordionBody = accordionItem.querySelector('.accordion-body');
                const isActive = accordionItem.classList.contains('active');

                // Close all other items
                document.querySelectorAll('.accordion-item').forEach(item => {
                    if (item !== accordionItem) {
                        item.classList.remove('active');
                        item.querySelector('.accordion-body').style.maxHeight = 0;
                    }
                });

                // Toggle the current item
                accordionItem.classList.toggle('active');
                if (!isActive) {
                    accordionBody.style.maxHeight = accordionBody.scrollHeight + 'px';
                } else {
                    accordionBody.style.maxHeight = 0;
                }
            });
        });
    </script>
</body>
</html>